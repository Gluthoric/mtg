File: /home/gluth/mtg/backend/config.py
================================================================================
import os
from dotenv import load_dotenv

# Load environment variables from the .env file
load_dotenv()

class Config:
    # The base configuration class that other environments will inherit from
    SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URI')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SECRET_KEY = os.getenv('SECRET_KEY')

class DevelopmentConfig(Config):
    # Development-specific settings
    DEBUG = True

class TestingConfig(Config):
    # Testing-specific settings
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.getenv('TEST_DATABASE_URI')

class ProductionConfig(Config):
    # Production-specific settings
    DEBUG = False

# Map configuration names to their corresponding config classes
config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
================================================================================

File: /home/gluth/mtg/backend/database.py
================================================================================
# Database initialization and models

from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

# Import models here to avoid circular imports
from models.card import Card
from models.set import Set
from models.collection import Collection
from models.kiosk import Kiosk
================================================================================

File: /home/gluth/mtg/backend/main.py
================================================================================
from flask import Flask, jsonify, request
from flask_cors import CORS
from config import Config
from database import db
from routes import register_routes
from routes.set_routes import set_routes
from routes.kiosk_routes import kiosk_routes
from routes.collection_routes import collection_routes
from models.collection import Collection
from models.kiosk import Kiosk
from models.card import Card
from sqlalchemy.sql import func, text
import redis
import orjson

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def get_api_stats(app):
    def _get_stats():
        cache_key = "api_stats"
        force_refresh = request.args.get('refresh', '').lower() == 'true'

        if not force_refresh:
            cached_data = app.redis_client.get(cache_key)
            if cached_data:
                return app.response_class(
                    response=cached_data,
                    status=200,
                    mimetype='application/json'
                )

        try:
            # Collection stats
            collection_total = db.session.query(func.sum(Collection.quantity_regular + Collection.quantity_foil)).scalar() or 0
            collection_unique = Collection.query.count()

            collection_value_query = text("""
                SELECT SUM(
                    (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * collections.quantity_regular) +
                    (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * collections.quantity_foil)
                )
                FROM collections
                JOIN cards ON cards.id = collections.card_id
            """)
            collection_value = db.session.execute(collection_value_query).scalar() or 0

            # Kiosk stats
            kiosk_total = db.session.query(func.sum(Kiosk.quantity_regular + Kiosk.quantity_foil)).scalar() or 0
            kiosk_unique = Kiosk.query.count()

            kiosk_value_query = text("""
                SELECT SUM(
                    (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * kiosk.quantity_regular) +
                    (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * kiosk.quantity_foil)
                )
                FROM kiosk
                JOIN cards ON cards.id = kiosk.card_id
            """)
            kiosk_value = db.session.execute(kiosk_value_query).scalar() or 0

            # Total stats
            total_cards = collection_total + kiosk_total
            total_unique = db.session.query(Card).filter(
                (Card.id.in_(db.session.query(Collection.card_id))) |
                (Card.id.in_(db.session.query(Kiosk.card_id)))
            ).count()
            total_value = collection_value + kiosk_value

            result = {
                'collection': {
                    'total_cards': int(collection_total),
                    'unique_cards': collection_unique,
                    'total_value': round(collection_value, 2)
                },
                'kiosk': {
                    'total_cards': int(kiosk_total),
                    'unique_cards': kiosk_unique,
                    'total_value': round(kiosk_value, 2)
                },
                'total': {
                    'total_cards': int(total_cards),
                    'unique_cards': total_unique,
                    'total_value': round(total_value, 2)
                }
            }

            serialized_data = orjson.dumps(result)
            app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

            return app.response_class(
                response=serialized_data,
                status=200,
                mimetype='application/json'
            )
        except Exception as e:
            return jsonify({"error": str(e)}), 500

    return _get_stats

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)

    # Initialize extensions
    db.init_app(app)
    CORS(app)

    # Register routes
    register_routes(app)
    app.register_blueprint(set_routes, url_prefix='/api')
    app.register_blueprint(kiosk_routes, url_prefix='/api')
    app.register_blueprint(collection_routes, url_prefix='/api')

    # Add Redis client to app context
    app.redis_client = redis_client

    # Use orjson for JSON serialization
    app.json_encoder = orjson.dumps
    app.json_decoder = orjson.loads

    # Register the /api/stats endpoint
    app.add_url_rule('/api/stats', 'get_api_stats', get_api_stats(app), methods=['GET'])

    return app

if __name__ == '__main__':
    app = create_app()
    app.run(debug=True)
================================================================================

File: /home/gluth/mtg/backend/README.md
================================================================================
# MTG Collection Kiosk Backend

This is the backend application for the Magic: The Gathering Collection Kiosk project.

## Project Setup

1. Make sure you have [Python](https://www.python.org/) (version 3.7 or higher) installed on your system.

2. Install [Redis](https://redis.io/download) on your system. It's used for caching to improve performance.

3. It's recommended to use a virtual environment. Create and activate one using:

   ```
   python -m venv venv
   source venv/bin/activate  # On Windows use `venv\Scripts\activate`
   ```

4. Install the required packages:

   ```
   pip install -r requirements.txt
   ```

5. Environment variables are already set up in the `.env` file in the `refactor/backend` directory. The file contains:

   ```
   DATABASE_URI=postgresql://postgres.xbuiunafhcscvjftnvxr:Timothy2-Sample-Underwent@aws-0-us-west-1.pooler.supabase.com:6543/postgres?sslmode=require
   SECRET_KEY=you-will-never-guess
   REDIS_URL=redis://localhost:6379/0
   ```

   If you need to modify these values:
   - Update the `DATABASE_URI` if you're using a different Supabase project or database.
   - Change the `SECRET_KEY` to a different secure random string of your choice.
   - Update the `REDIS_URL` if your Redis server is not running on the default localhost:6379.

## Running the Development Server

To start the development server, run:

```
python main.py
```

This will start the Flask development server, usually at `http://localhost:5000`.

Make sure your Redis server is running before starting the application.

## Database Initialization

The application is set up to automatically initialize the database when you run `main.py`. Here's how it works:

- When you start the application, it checks if the database tables already exist.
- If the tables don't exist (i.e., it's a fresh installation), it will create all necessary tables.
- If the tables already exist, it won't make any changes to the database structure.

This approach ensures that your existing data is not overwritten when you start the application. However, it's important to note that this method doesn't handle database migrations. If you make changes to your database models, you'll need to manually update your database schema or use a migration tool like Alembic.

## Project Structure

- `main.py`: The main entry point of the application
- `config.py`: Configuration settings
- `models/`: Database models
- `routes/`: API route definitions
- `database.py`: Database connection and session management
- `.env`: Environment variables (including database connection details)

## API Endpoints

- `/api/cards`: Card-related operations
- `/api/sets`: Set-related operations
- `/api/collection`: Collection management
- `/api/kiosk`: Kiosk inventory management
- `/api/import`: Card import operations

For detailed API documentation, refer to the inline comments in the route files.

## Database

This project uses SQLAlchemy with PostgreSQL, connected to a Supabase instance. The connection details are managed through the `DATABASE_URI` environment variable in the `.env` file.

## Performance Optimizations

The backend has been optimized for better performance, particularly focusing on the collection-related routes:

1. **Caching with Redis**: Frequently accessed data is cached using Redis, reducing database load and improving response times. The cache is automatically invalidated when data is updated. This includes:
   - Collection data
   - Collection sets data
   - Collection statistics
   - Set cards in the collection

2. **Efficient Serialization**: The `orjson` library is used for faster JSON serialization and deserialization, particularly beneficial for large datasets.

3. **Query Optimization**: Database queries have been optimized to reduce the load on the database and improve response times.

4. **Pagination**: All list endpoints support pagination to handle large datasets efficiently.

5. **Cache Invalidation**: When data is updated (e.g., adding or removing cards from the collection), related caches are automatically invalidated to ensure data consistency.

These optimizations significantly improve the application's performance, especially when dealing with large collections or high traffic.

## Additional Notes

- This project uses Flask as the web framework and SQLAlchemy as the ORM.
- Make sure to handle CORS appropriately when connecting with the frontend.
- Always keep your `SECRET_KEY` and database credentials secure and never commit them to version control.

For more information on Flask and SQLAlchemy, check out the [Flask documentation](https://flask.palletsprojects.com/) and [SQLAlchemy documentation](https://docs.sqlalchemy.org/).
================================================================================

File: /home/gluth/mtg/backend/requirements.txt
================================================================================
Flask
Flask-SQLAlchemy
Flask-Cors
psycopg2-binary
python-dotenv
SQLAlchemy
pandas
orjson
redis
================================================================================

File: /home/gluth/mtg/backend/models/card.py
================================================================================
from database import db
from sqlalchemy.dialects.postgresql import JSONB

class Card(db.Model):
    __tablename__ = 'cards'

    id = db.Column(db.Text, primary_key=True)
    oracle_id = db.Column(db.Text, index=True)
    multiverse_ids = db.Column(JSONB)
    mtgo_id = db.Column(db.BigInteger)
    arena_id = db.Column(db.BigInteger)
    tcgplayer_id = db.Column(db.BigInteger)
    name = db.Column(db.Text, nullable=False, index=True)
    lang = db.Column(db.Text)
    released_at = db.Column(db.Text)
    uri = db.Column(db.Text)
    scryfall_uri = db.Column(db.Text)
    layout = db.Column(db.Text)
    highres_image = db.Column(db.Boolean)
    image_status = db.Column(db.Text)
    image_uris = db.Column(JSONB)  # Now correctly mapped to JSONB
    mana_cost = db.Column(db.Text)
    cmc = db.Column(db.Float)
    type_line = db.Column(db.Text, index=True)
    oracle_text = db.Column(db.Text)
    colors = db.Column(JSONB)
    color_identity = db.Column(JSONB)
    keywords = db.Column(JSONB)
    produced_mana = db.Column(JSONB)
    legalities = db.Column(JSONB)
    games = db.Column(JSONB)
    reserved = db.Column(db.Boolean)
    foil = db.Column(db.Boolean)
    nonfoil = db.Column(db.Boolean)
    finishes = db.Column(JSONB)
    oversized = db.Column(db.Boolean)
    promo = db.Column(db.Boolean)
    full_art = db.Column(db.Boolean)
    textless = db.Column(db.Boolean)
    booster = db.Column(db.Boolean)
    story_spotlight = db.Column(db.Boolean)
    reprint = db.Column(db.Boolean)
    variation = db.Column(db.Boolean)
    set_code = db.Column(db.Text, db.ForeignKey('sets.code'), index=True)
    set_name = db.Column(db.Text)
    collector_number = db.Column(db.Text, nullable=False, default='0')
    digital = db.Column(db.Boolean)
    rarity = db.Column(db.Text, index=True)
    card_back_id = db.Column(db.Text)
    artist = db.Column(db.Text)
    artist_ids = db.Column(JSONB)
    illustration_id = db.Column(db.Text)
    border_color = db.Column(db.Text)
    frame = db.Column(db.Text)
    prices = db.Column(JSONB)
    related_uris = db.Column(JSONB)
    purchase_uris = db.Column(JSONB)

    # Relationships
    set = db.relationship('Set', back_populates='cards')
    collection = db.relationship('Collection', back_populates='card', uselist=False, cascade='all, delete-orphan')
    kiosk = db.relationship('Kiosk', back_populates='card', uselist=False, cascade='all, delete-orphan')

    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'set_name': self.set_name,
            'set_code': self.set_code,
            'collector_number': self.collector_number if self.collector_number else 'N/A',
            'type_line': self.type_line,
            'rarity': self.rarity,
            'mana_cost': self.mana_cost,
            'cmc': self.cmc,
            'oracle_text': self.oracle_text,
            'colors': self.colors,
            'image_uris': self.image_uris if self.image_uris else {},
            'prices': self.prices,
            'collection': self.collection.to_dict() if self.collection else None,
            'kiosk': self.kiosk.to_dict() if self.kiosk else None
        }
================================================================================

File: /home/gluth/mtg/backend/models/collection.py
================================================================================
from database import db

class Collection(db.Model):
    __tablename__ = 'collections'

    id = db.Column(db.BigInteger, primary_key=True, autoincrement=True)
    card_id = db.Column(db.Text, db.ForeignKey('cards.id'), nullable=False)
    quantity_regular = db.Column(db.BigInteger, default=0)
    quantity_foil = db.Column(db.BigInteger, default=0)

    # Relationship
    card = db.relationship('Card', back_populates='collection')

    def to_dict(self):
        return {
            'id': self.id,
            'card_id': self.card_id,
            'quantity_regular': self.quantity_regular,
            'quantity_foil': self.quantity_foil
        }
================================================================================

File: /home/gluth/mtg/backend/models/kiosk.py
================================================================================
from database import db

class Kiosk(db.Model):
    __tablename__ = 'kiosk'

    id = db.Column(db.BigInteger, primary_key=True, autoincrement=True)
    card_id = db.Column(db.Text, db.ForeignKey('cards.id'), nullable=False)
    quantity_regular = db.Column(db.BigInteger, default=0)
    quantity_foil = db.Column(db.BigInteger, default=0)

    # Relationship
    card = db.relationship('Card', back_populates='kiosk')

    def to_dict(self):
        return {
            'id': self.id,
            'card_id': self.card_id,
            'quantity_regular': self.quantity_regular,
            'quantity_foil': self.quantity_foil
        }
================================================================================

File: /home/gluth/mtg/backend/models/set.py
================================================================================
from database import db
from models.collection import Collection
from models.card import Card

class Set(db.Model):
    __tablename__ = 'sets'

    id = db.Column(db.Text, primary_key=True)
    code = db.Column(db.Text, unique=True, nullable=False, index=True)
    name = db.Column(db.Text, nullable=False)
    released_at = db.Column(db.Text)
    set_type = db.Column(db.Text)
    card_count = db.Column(db.BigInteger)
    digital = db.Column(db.Boolean)
    foil_only = db.Column(db.Boolean)
    icon_svg_uri = db.Column(db.Text)

    # Relationships
    cards = db.relationship('Card', back_populates='set')

    def to_dict(self):
        collection_count = self.get_collection_count()
        collection_percentage = (collection_count / self.card_count) * 100 if self.card_count else 0
        return {
            'id': self.id,
            'code': self.code,
            'name': self.name,
            'released_at': self.released_at,
            'set_type': self.set_type,
            'card_count': self.card_count,
            'digital': self.digital,
            'foil_only': self.foil_only,
            'icon_svg_uri': self.icon_svg_uri,
            'collection_count': collection_count,
            'collection_percentage': collection_percentage
        }

    def get_collection_count(self):
        # Count the number of unique cards in the collection for this set
        return db.session.query(db.func.count(Collection.card_id)) \
            .join(Card, Card.id == Collection.card_id) \
            .filter(Card.set_code == self.code) \
            .scalar() or 0
================================================================================

File: /home/gluth/mtg/backend/routes/__init__.py
================================================================================
from flask import Blueprint
from .card_routes import card_routes
from .set_routes import set_routes
from .collection_routes import collection_routes
from .kiosk_routes import kiosk_routes

def register_routes(app):
    api = Blueprint('api', __name__, url_prefix='/api')

    api.register_blueprint(card_routes)
    api.register_blueprint(set_routes)
    api.register_blueprint(collection_routes)
    api.register_blueprint(kiosk_routes)

    app.register_blueprint(api)

    @app.route('/')
    def index():
        return "Welcome to the MTG Collection Kiosk API"
================================================================================

File: /home/gluth/mtg/backend/routes/card_routes.py
================================================================================
from flask import Blueprint, jsonify, request
from models.card import Card
from database import db
from sqlalchemy import or_

card_routes = Blueprint('card_routes', __name__)

@card_routes.route('/cards', methods=['GET'])
def get_cards():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    name = request.args.get('name', '')
    set_code = request.args.get('set_code', '')
    rarity = request.args.get('rarity', '')
    colors = request.args.get('colors', '').split(',') if request.args.get('colors') else []

    query = Card.query

    if name:
        query = query.filter(Card.name.ilike(f'%{name}%'))
    if set_code:
        query = query.filter(Card.set_code == set_code)
    if rarity:
        query = query.filter(Card.rarity == rarity)
    if colors:
        query = query.filter(or_(*[Card.colors.contains([color]) for color in colors]))

    cards = query.paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'cards': [card.to_dict() for card in cards.items],
        'total': cards.total,
        'pages': cards.pages,
        'current_page': page
    }), 200

@card_routes.route('/cards/<string:card_id>', methods=['GET'])
def get_card(card_id):
    card = Card.query.get_or_404(card_id)
    return jsonify(card.to_dict()), 200

@card_routes.route('/cards/search', methods=['GET'])
def search_cards():
    query = request.args.get('q', '')
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)

    cards = Card.query.filter(
        or_(
            Card.name.ilike(f'%{query}%'),
            Card.type_line.ilike(f'%{query}%'),
            Card.oracle_text.ilike(f'%{query}%')
        )
    ).paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'cards': [card.to_dict() for card in cards.items],
        'total': cards.total,
        'pages': cards.pages,
        'current_page': page
    }), 200
================================================================================

File: /home/gluth/mtg/backend/routes/collection_routes.py
================================================================================
import pandas as pd
from flask import Blueprint, jsonify, request, current_app
from sqlalchemy.orm import joinedload
from sqlalchemy.sql import func, asc, desc, text
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from models.collection import Collection
from models.card import Card
from models.kiosk import Kiosk
from models.set import Set
from database import db
import time
import logging
import orjson

collection_routes = Blueprint('collection_routes', __name__)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def serialize_collection(collection_items):
    return [{
        **item.card.to_dict(),
        'quantity_regular': item.quantity_regular,
        'quantity_foil': item.quantity_foil
    } for item in collection_items]

@collection_routes.route('/collection', methods=['GET'])
def get_collection():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    set_code = request.args.get('set_code', '', type=str)

    cache_key = f"collection:page:{page}:per_page:{per_page}:set_code:{set_code}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    query = Collection.query.join(Card).join(Set)

    if set_code:
        query = query.filter(Set.code == set_code)

    collection = query.paginate(page=page, per_page=per_page, error_out=False)

    result = {
        'collection': serialize_collection(collection.items),
        'total': collection.total,
        'pages': collection.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@collection_routes.route('/collection/sets', methods=['GET'])
def get_collection_sets():
    try:
        name = request.args.get('name', type=str)
        set_type = request.args.get('set_type', type=str)
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        sort_by = request.args.get('sort_by', 'released_at', type=str)
        sort_order = request.args.get('sort_order', 'desc', type=str)

        cache_key = f"collection_sets:name:{name}:set_type:{set_type}:page:{page}:per_page:{per_page}:sort_by:{sort_by}:sort_order:{sort_order}"
        cached_data = current_app.redis_client.get(cache_key)

        if cached_data:
            return current_app.response_class(
                response=cached_data,
                status=200,
                mimetype='application/json'
            )

        logger.info(f"Received parameters: name={name}, set_type={set_type}, sort_by={sort_by}, sort_order={sort_order}, page={page}, per_page={per_page}")

        query = db.session.query(
            Set.id,
            Set.code,
            Set.name,
            Set.released_at,
            Set.set_type,
            Set.card_count,
            Set.digital,
            Set.foil_only,
            Set.icon_svg_uri,
            func.count(Collection.card_id).label('collection_count')
        ).outerjoin(Card, Card.set_code == Set.code
        ).outerjoin(Collection, Collection.card_id == Card.id
        ).group_by(
            Set.id,
            Set.code,
            Set.name,
            Set.released_at,
            Set.set_type,
            Set.card_count,
            Set.digital,
            Set.foil_only,
            Set.icon_svg_uri
        )

        if name:
            query = query.filter(Set.name.ilike(f'%{name}%'))
            logger.info(f"Applied filter: Set.name ilike '%{name}%'")
        if set_type:
            query = query.filter(Set.set_type == set_type)
            logger.info(f"Applied filter: Set.set_type == '{set_type}'")

        valid_sort_fields = {'released_at', 'name', 'collection_count', 'card_count'}
        if sort_by not in valid_sort_fields:
            error_message = f"Invalid sort_by field: {sort_by}"
            logger.error(error_message)
            return jsonify({"error": error_message}), 400

        if sort_by == 'collection_count':
            sort_column = func.count(Collection.card_id)
        else:
            sort_column = getattr(Set, sort_by)

        if sort_order.lower() == 'asc':
            query = query.order_by(asc(sort_column))
            logger.info(f"Sorting by {sort_by} in ascending order")
        else:
            query = query.order_by(desc(sort_column))
            logger.info(f"Sorting by {sort_by} in descending order")

        paginated_sets = query.paginate(page=page, per_page=per_page, error_out=False)
        logger.info(f"Paginated sets: page={paginated_sets.page}, pages={paginated_sets.pages}, total={paginated_sets.total}")

        sets_list = []
        for row in paginated_sets.items:
            set_data = {
                'id': row.id,
                'code': row.code,
                'name': row.name,
                'released_at': row.released_at,
                'set_type': row.set_type,
                'card_count': row.card_count,
                'digital': row.digital,
                'foil_only': row.foil_only,
                'icon_svg_uri': row.icon_svg_uri
            }
            collection_count = row.collection_count
            collection_percentage = (collection_count / row.card_count) * 100 if row.card_count else 0
            sets_list.append({
                **set_data,
                'collection_count': collection_count,
                'collection_percentage': collection_percentage
            })

        response = {
            'sets': sets_list,
            'total': paginated_sets.total,
            'pages': paginated_sets.pages,
            'current_page': paginated_sets.page
        }

        serialized_data = orjson.dumps(response)
        current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

        logger.info(f"Returning response with {len(sets_list)} sets")
        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        error_message = f"An unexpected error occurred: {str(e)}"
        logger.exception(error_message)
        return jsonify({"error": error_message}), 500

@collection_routes.route('/collection/<string:card_id>', methods=['POST', 'PUT'])
def update_collection(card_id):
    data = request.json
    quantity_regular = data.get('quantity_regular', 0)
    quantity_foil = data.get('quantity_foil', 0)

    collection_item = Collection.query.filter_by(card_id=card_id).first()

    if collection_item:
        collection_item.quantity_regular = quantity_regular
        collection_item.quantity_foil = quantity_foil
    else:
        collection_item = Collection(card_id=card_id, quantity_regular=quantity_regular, quantity_foil=quantity_foil)
        db.session.add(collection_item)

    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("collection:*")
    current_app.redis_client.delete("collection_sets:*")
    current_app.redis_client.delete("collection_stats")

    card = Card.query.filter_by(id=card_id).first()
    if not card:
        return jsonify({"error": "Card not found."}), 404

    card_data = card.to_dict()
    card_data.update({
        'quantity_regular': collection_item.quantity_regular,
        'quantity_foil': collection_item.quantity_foil
    })

    return current_app.response_class(
        response=orjson.dumps(card_data),
        status=200,
        mimetype='application/json'
    )

@collection_routes.route('/collection/<string:card_id>', methods=['DELETE'])
def remove_from_collection(card_id):
    collection_item = Collection.query.filter_by(card_id=card_id).first_or_404()
    db.session.delete(collection_item)
    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("collection:*")
    current_app.redis_client.delete("collection_sets:*")
    current_app.redis_client.delete("collection_stats")

    return '', 204

@collection_routes.route('/collection/stats', methods=['GET'])
def get_collection_stats():
    try:
        cache_key = "collection_stats"
        cached_data = current_app.redis_client.get(cache_key)

        if cached_data:
            return current_app.response_class(
                response=cached_data,
                status=200,
                mimetype='application/json'
            )

        total_cards = db.session.query(func.sum(Collection.quantity_regular + Collection.quantity_foil)).scalar() or 0
        unique_cards = Collection.query.count()

        total_value_query = text("""
            SELECT SUM(
                (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * collections.quantity_regular) +
                (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * collections.quantity_foil)
            )
            FROM collections
            JOIN cards ON cards.id = collections.card_id
        """)
        total_value = db.session.execute(total_value_query).scalar() or 0

        result = {
            'total_cards': int(total_cards),
            'unique_cards': unique_cards,
            'total_value': round(total_value, 2)
        }

        serialized_data = orjson.dumps(result)
        current_app.redis_client.setex(cache_key, 3600, serialized_data)  # Cache for 1 hour

        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@collection_routes.route('/collection/sets/<string:set_code>/cards', methods=['GET'])
def get_collection_set_cards(set_code):
    name = request.args.get('name', '', type=str)
    rarity = request.args.get('rarity', '', type=str)
    colors = request.args.getlist('colors') + request.args.getlist('colors[]')

    try:
        query = Card.query.outerjoin(Collection).join(Set).filter(Set.code == set_code)

        if name:
            query = query.filter(Card.name.ilike(f'%{name}%'))
        if rarity:
            query = query.filter(Card.rarity == rarity)
        if colors:
            VALID_COLORS = {'W', 'U', 'B', 'R', 'G'}
            invalid_colors = set(colors) - VALID_COLORS
            if invalid_colors:
                return jsonify({"error": f"Invalid colors: {', '.join(invalid_colors)}"}), 400

            colors_str = "{" + ",".join(f'"{c}"' for c in colors) + "}"
            query = query.filter(text("cards.colors ?| :colors_str").bindparams(colors_str=colors_str))

        # Log the SQL query
        logger.info(f"Executing query: {query}")

        cards = query.all()

        # Log the number of cards returned
        logger.info(f"Number of cards returned: {len(cards)}")

        result = {
            'cards': [{
                **card.to_dict(),
                'quantity_regular': card.collection.quantity_regular if card.collection else 0,
                'quantity_foil': card.collection.quantity_foil if card.collection else 0
            } for card in cards],
            'total': len(cards),
        }

        # Log the first few cards for debugging
        logger.info(f"First 5 cards: {result['cards'][:5]}")

        return jsonify(result), 200
    except Exception as e:
        error_message = f"An unexpected error occurred: {str(e)}"
        logger.exception(error_message)
        return jsonify({"error": error_message}), 500

@collection_routes.route('/collection/import_csv', methods=['POST'])
def import_csv():
    if 'file' not in request.files:
        return jsonify({"error": "No file part in the request"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No file selected"}), 400

    if not file.filename.endswith('.csv'):
        return jsonify({"error": "Only CSV files are allowed"}), 400

    try:
        df = pd.read_csv(file)
    except Exception as e:
        logger.error(f"Failed to parse CSV: {str(e)}")
        return jsonify({"error": f"Failed to parse CSV: {str(e)}"}), 400

    required_columns = {
        'Name', 'Edition', 'Edition code', "Collector's number",
        'Price', 'Foil', 'Currency', 'Scryfall ID', 'Quantity'
    }
    if not required_columns.issubset(set(df.columns)):
        missing = required_columns - set(df.columns)
        return jsonify({"error": f"CSV is missing columns: {', '.join(missing)}"}), 400

    df['Foil'] = df['Foil'].fillna(False).replace('', False)

    try:
        with db.session.begin_nested():
            for index, row in df.iterrows():
                try:
                    process_csv_row(row, index)
                except ValueError as e:
                    logger.error(f"Error processing row {index + 2}: {str(e)}")
                    continue
                except IntegrityError as e:
                    logger.error(f"IntegrityError at row {index + 2}: {str(e)}")
                    db.session.rollback()
                    return jsonify({"error": f"Database integrity error at row {index + 2}: {str(e)}"}), 500

                if index % 100 == 0:
                    db.session.flush()

        db.session.commit()
        logger.info("CSV imported successfully")

        # Invalidate related caches
        current_app.redis_client.delete("collection:*")
        current_app.redis_client.delete("collection_sets:*")
        current_app.redis_client.delete("collection_stats")

        return jsonify({"message": "CSV imported successfully"}), 200

    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error(f"Database error during CSV import: {str(e)}")
        return jsonify({"error": f"Database error: {str(e)}"}), 500

def process_csv_row(row, index):
    scryfall_id = row['Scryfall ID']
    card_name = row['Name']

    try:
        quantity = int(row['Quantity'])
        if quantity < 1:
            raise ValueError(f"Invalid quantity for card '{card_name}' at row {index + 2}.")
    except ValueError:
        raise ValueError(f"Invalid quantity for card '{card_name}' at row {index + 2}.")

    foil = row['Foil']
    if isinstance(foil, bool):
        foil_status = foil
    else:
        raise ValueError(f"Foil value must be boolean for card '{card_name}' at row {index + 2}.")

    card = Card.query.filter_by(id=scryfall_id).first()
    if not card:
        raise ValueError(f"Card with Scryfall ID '{scryfall_id}' not found in the database.")

    collection_item = Collection.query.filter_by(card_id=card.id).first()
    kiosk_item = Kiosk.query.filter_by(card_id=card.id).first()

    if foil_status:
        handle_foil_card(card, quantity, collection_item, kiosk_item)
    else:
        handle_non_foil_card(card, quantity, collection_item, kiosk_item)

def handle_foil_card(card, quantity, collection_item, kiosk_item):
    if collection_item and collection_item.quantity_foil > 0:
        if kiosk_item:
            kiosk_item.quantity_foil += quantity
        else:
            kiosk_item = Kiosk(card_id=card.id, quantity_foil=quantity)
            db.session.add(kiosk_item)
    else:
        to_collection = 1 if quantity >= 1 else 0
        to_kiosk = quantity - to_collection

        if to_collection > 0:
            if collection_item:
                collection_item.quantity_foil += to_collection
            else:
                collection_item = Collection(card_id=card.id, quantity_foil=to_collection)
                db.session.add(collection_item)

        if to_kiosk > 0:
            if kiosk_item:
                kiosk_item.quantity_foil += to_kiosk
            else:
                kiosk_item = Kiosk(card_id=card.id, quantity_foil=to_kiosk)
                db.session.add(kiosk_item)

def handle_non_foil_card(card, quantity, collection_item, kiosk_item):
    has_collection_copy = collection_item and (collection_item.quantity_regular > 0 or collection_item.quantity_foil > 0)

    if not has_collection_copy:
        to_collection = 1 if quantity >= 1 else 0
        to_kiosk = quantity - to_collection

        if to_collection > 0:
            if collection_item:
                collection_item.quantity_regular += to_collection
            else:
                collection_item = Collection(card_id=card.id, quantity_regular=to_collection)
                db.session.add(collection_item)

        if to_kiosk > 0:
            if kiosk_item:
                kiosk_item.quantity_regular += to_kiosk
            else:
                kiosk_item = Kiosk(card_id=card.id, quantity_regular=to_kiosk)
                db.session.add(kiosk_item)
    else:
        if kiosk_item:
            kiosk_item.quantity_regular += quantity
        else:
            kiosk_item = Kiosk(card_id=card.id, quantity_regular=quantity)
            db.session.add(kiosk_item)

================================================================================

File: /home/gluth/mtg/backend/routes/kiosk_routes.py
================================================================================
from flask import Blueprint, jsonify, request, current_app
from models.kiosk import Kiosk
from models.card import Card
from models.set import Set
from database import db
from sqlalchemy.sql import func, text
from sqlalchemy import distinct
import orjson

kiosk_routes = Blueprint('kiosk_routes', __name__)

def serialize_sets(sets):
    return [set_obj.to_dict() for set_obj in sets]

def serialize_cards(cards):
    return [{**card.to_dict(), 'quantity': kiosk_item.to_dict()} for card, kiosk_item in cards]

@kiosk_routes.route('/kiosk', methods=['GET'])
def get_kiosk():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)

    cache_key = f"kiosk:page:{page}:per_page:{per_page}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    kiosk = Kiosk.query.join(Card).paginate(page=page, per_page=per_page, error_out=False)

    result = {
        'kiosk': [
            {**item.card.to_dict(), 'quantity': item.to_dict()}
            for item in kiosk.items
        ],
        'total': kiosk.total,
        'pages': kiosk.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/sets', methods=['GET'])
def get_kiosk_sets():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    sort_by = request.args.get('sortBy', 'released_at')
    sort_order = request.args.get('sortOrder', 'desc')

    cache_key = f"kiosk_sets:page:{page}:per_page:{per_page}:sort_by:{sort_by}:sort_order:{sort_order}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    kiosk_sets = db.session.query(Set).\
        join(Card, Card.set_code == Set.code).\
        join(Kiosk, Kiosk.card_id == Card.id).\
        filter((Kiosk.quantity_regular > 0) | (Kiosk.quantity_foil > 0)).\
        distinct()

    if sort_order == 'desc':
        kiosk_sets = kiosk_sets.order_by(getattr(Set, sort_by).desc())
    else:
        kiosk_sets = kiosk_sets.order_by(getattr(Set, sort_by))

    paginated_sets = kiosk_sets.paginate(page=page, per_page=per_page, error_out=False)

    sets_data = []
    for set_obj in paginated_sets.items:
        set_dict = set_obj.to_dict()

        kiosk_count = db.session.query(func.count(distinct(Card.id))).\
            join(Kiosk, Kiosk.card_id == Card.id).\
            filter(Card.set_code == set_obj.code).\
            filter((Kiosk.quantity_regular > 0) | (Kiosk.quantity_foil > 0)).\
            scalar()

        set_dict['kiosk_count'] = kiosk_count
        set_dict['kiosk_percentage'] = (kiosk_count / set_obj.card_count) * 100 if set_obj.card_count > 0 else 0

        sets_data.append(set_dict)

    result = {
        'sets': sets_data,
        'total': paginated_sets.total,
        'pages': paginated_sets.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 600, serialized_data)  # Cache for 10 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/sets/<string:set_code>/cards', methods=['GET'])
def get_kiosk_set_cards(set_code):
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    name_filter = request.args.get('name', '')
    rarity_filter = request.args.get('rarity', '')
    sort_by = request.args.get('sortBy', 'name')
    sort_order = request.args.get('sortOrder', 'asc')

    cache_key = f"kiosk_set_cards:{set_code}:page:{page}:per_page:{per_page}:name:{name_filter}:rarity:{rarity_filter}:sort_by:{sort_by}:sort_order:{sort_order}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    query = db.session.query(Card, Kiosk).\
        join(Kiosk, Kiosk.card_id == Card.id).\
        filter(Card.set_code == set_code).\
        filter((Kiosk.quantity_regular > 0) | (Kiosk.quantity_foil > 0))

    if name_filter:
        query = query.filter(Card.name.ilike(f'%{name_filter}%'))
    if rarity_filter:
        query = query.filter(Card.rarity == rarity_filter)

    if sort_order == 'desc':
        query = query.order_by(getattr(Card, sort_by).desc())
    else:
        query = query.order_by(getattr(Card, sort_by))

    paginated_cards = query.paginate(page=page, per_page=per_page, error_out=False)

    cards_data = []
    for card, kiosk_item in paginated_cards.items:
        card_dict = card.to_dict()
        card_dict['quantity'] = kiosk_item.to_dict()
        cards_data.append(card_dict)

    set_name = Set.query.filter_by(code=set_code).first().name

    result = {
        'cards': cards_data,
        'set_name': set_name,
        'total': paginated_cards.total,
        'pages': paginated_cards.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/<string:card_id>', methods=['POST', 'PUT'])
def update_kiosk(card_id):
    data = request.json
    quantity_regular = data.get('quantity_regular', 0)
    quantity_foil = data.get('quantity_foil', 0)

    kiosk_item = Kiosk.query.filter_by(card_id=card_id).first()

    if kiosk_item:
        kiosk_item.quantity_regular = quantity_regular
        kiosk_item.quantity_foil = quantity_foil
    else:
        kiosk_item = Kiosk(card_id=card_id, quantity_regular=quantity_regular, quantity_foil=quantity_foil)
        db.session.add(kiosk_item)

    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("kiosk:*")
    current_app.redis_client.delete("kiosk_sets:*")
    current_app.redis_client.delete(f"kiosk_set_cards:{kiosk_item.card.set_code}:*")

    return current_app.response_class(
        response=orjson.dumps(kiosk_item.to_dict()),
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/<string:card_id>', methods=['DELETE'])
def remove_from_kiosk(card_id):
    kiosk_item = Kiosk.query.filter_by(card_id=card_id).first_or_404()
    set_code = kiosk_item.card.set_code
    db.session.delete(kiosk_item)
    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("kiosk:*")
    current_app.redis_client.delete("kiosk_sets:*")
    current_app.redis_client.delete(f"kiosk_set_cards:{set_code}:*")

    return '', 204

@kiosk_routes.route('/kiosk/stats', methods=['GET'])
def get_kiosk_stats():
    cache_key = "kiosk_stats"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    try:
        total_cards = db.session.query(func.sum(Kiosk.quantity_regular + Kiosk.quantity_foil)).scalar() or 0
        unique_cards = Kiosk.query.count()

        total_value_query = text("""
            SELECT SUM(
                (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * kiosk.quantity_regular) +
                (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * kiosk.quantity_foil)
            )
            FROM kiosk
            JOIN cards ON cards.id = kiosk.card_id
        """)
        total_value = db.session.execute(total_value_query).scalar() or 0

        result = {
            'total_cards': int(total_cards),
            'unique_cards': unique_cards,
            'total_value': round(total_value, 2)
        }

        serialized_data = orjson.dumps(result)
        current_app.redis_client.setex(cache_key, 3600, serialized_data)  # Cache for 1 hour

        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500
================================================================================

File: /home/gluth/mtg/backend/routes/set_routes.py
================================================================================
from flask import Blueprint, jsonify, request
from models.set import Set
from models.card import Card
from database import db
from sqlalchemy import asc, desc
from sqlalchemy.orm import joinedload

set_routes = Blueprint('set_routes', __name__)

@set_routes.route('/sets', methods=['GET'])
def get_all_sets():
    try:
        # Extract query parameters
        name = request.args.get('name', type=str, default='')
        set_type = request.args.get('set_type', type=str, default='')
        sort_by = request.args.get('sort_by', type=str, default='released_at')
        sort_order = request.args.get('sort_order', type=str, default='desc')
        page = request.args.get('page', type=int, default=1)
        per_page = request.args.get('per_page', type=int, default=20)

        query = Set.query

        # Apply filters
        if name:
            query = query.filter(Set.name.ilike(f'%{name}%'))
        if set_type:
            query = query.filter(Set.set_type == set_type)

        # Apply sorting
        if sort_order.lower() == 'asc':
            query = query.order_by(asc(getattr(Set, sort_by)))
        else:
            query = query.order_by(desc(getattr(Set, sort_by)))

        # Apply pagination
        paginated_sets = query.paginate(page=page, per_page=per_page, error_out=False)

        sets = [set.to_dict() for set in paginated_sets.items]

        return jsonify({
            'sets': sets,
            'total': paginated_sets.total,
            'pages': paginated_sets.pages,
            'current_page': paginated_sets.page
        }), 200
    except AttributeError:
        return jsonify({"error": f"Invalid sort_by field: {sort_by}"}), 400
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@set_routes.route('/sets/<string:set_code>', methods=['GET'])
def get_set(set_code):
    set_instance = Set.query.filter_by(code=set_code).first_or_404()
    return jsonify(set_instance.to_dict()), 200

@set_routes.route('/sets/<string:set_code>/cards', methods=['GET'])
def get_set_cards(set_code):
    # Extract filter parameters
    name_filter = request.args.get('name', '', type=str)
    rarity_filter = request.args.get('rarity', '', type=str)

    # Eagerly load related 'collection' and 'set' data to optimize queries
    query = Card.query.options(
        joinedload(Card.collection),
        joinedload(Card.set)
    ).filter(Card.set_code == set_code)

    # Apply filters based on query parameters
    if name_filter:
        query = query.filter(Card.name.ilike(f'%{name_filter}%'))
    if rarity_filter:
        query = query.filter(Card.rarity == rarity_filter)

    # Fetch all matching cards without pagination
    cards = query.all()

    # Serialize card data
    cards_data = []
    for card in cards:
        card_dict = {
            'id': card.id,
            'name': card.name,
            'rarity': card.rarity,
            'quantity_regular': card.collection.quantity_regular if card.collection else 0,
            'quantity_foil': card.collection.quantity_foil if card.collection else 0,
            'set_name': card.set.name if card.set else '',
            'set_code': card.set_code,
            'collector_number': card.collector_number,
            'mana_cost': card.mana_cost,
            'cmc': card.cmc,
            'type_line': card.type_line,
            'oracle_text': card.oracle_text,
            'colors': card.colors,
            'color_identity': card.color_identity,
            'keywords': card.keywords,
            'legalities': card.legalities,
            'reserved': card.reserved,
            'foil': card.foil,
            'nonfoil': card.nonfoil,
            'full_art': card.full_art,
            'textless': card.textless,
            'promo': card.promo,
            'reprint': card.reprint,
            'variation': card.variation,
            'artist': card.artist,
            'frame': card.frame,
            'border_color': card.border_color,
            'released_at': card.released_at,
            'prices': card.prices,
        }
        # Include image URIs
        if hasattr(card, 'image_uris') and card.image_uris:
            card_dict['image_uris'] = card.image_uris

        # Include related URIs
        if card.related_uris:
            card_dict['related_uris'] = card.related_uris

        # Include purchase URIs
        if card.purchase_uris:
            card_dict['purchase_uris'] = card.purchase_uris

        cards_data.append(card_dict)

    return jsonify({
        'cards': cards_data,
        'total': len(cards_data),
        'pages': 1,
        'current_page': 1
    }), 200

================================================================================

