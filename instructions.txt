2. Frontend Enhancements
2.1. Update the Import Component to Handle CSV Uploads

We'll modify the existing Import.vue component to correctly handle CSV uploads and interact with the new backend endpoint.

Steps:

    Ensure the Import Form Points to the Correct Endpoint:

    Update the form action to send the CSV to /api/collection/import_csv.

    Update the Import Function:

    Modify the importFromCSV method to send the CSV to the new endpoint.

Updated Import.vue:

vue

<!-- frontend/src/views/Import.vue -->

<template>
  <div class="import">
    <h1>Import Cards</h1>

    <div class="import-section">
      <h2>Import Single Card</h2>
      <form @submit.prevent="importSingleCard">
        <!-- Existing Single Card Import Fields -->
        <!-- ... -->
      </form>
    </div>

    <div class="import-section">
      <h2>Import from CSV</h2>
      <form @submit.prevent="importFromCSV">
        <div>
          <label for="csvFile">CSV File:</label>
          <input type="file" id="csvFile" @change="handleFileUpload" accept=".csv" required>
        </div>
        <div>
          <label for="csvDestination">Destination:</label>
          <select v-model="csvImport.destination" id="csvDestination" required>
            <option value="collection">Collection</option>
            <option value="kiosk">Kiosk</option>
          </select>
        </div>
        <button type="submit">Import CSV</button>
      </form>
    </div>

    <div v-if="message" :class="['message', messageType]">
      {{ message }}
    </div>
  </div>
</template>

<script>
import { ref } from 'vue'
import axios from 'axios'

export default {
  name: 'Import',
  setup() {
    const singleCard = ref({
      scryfallId: '',
      quantity: 1,
      foil: false,
      destination: 'collection'
    })

    const csvImport = ref({
      file: null,
      destination: 'collection'
    })

    const message = ref('')
    const messageType = ref('')

    const importSingleCard = async () => {
      try {
        const response = await axios.post(`/api/collection`, {
          scryfallid: singleCard.value.scryfallId,
          quantity: singleCard.value.quantity,
          foil: singleCard.value.foil ? 1 : 0
        })
        message.value = `Card imported successfully: ${response.data.message}`
        messageType.value = 'success'
        // Reset form
        singleCard.value = { scryfallId: '', quantity: 1, foil: false, destination: 'collection' }
      } catch (error) {
        message.value = `Error importing card: ${error.response?.data?.error || error.message}`
        messageType.value = 'error'
      }
    }

    const handleFileUpload = (event) => {
      csvImport.value.file = event.target.files[0]
    }

    const importFromCSV = async () => {
      if (!csvImport.value.file) {
        message.value = 'Please select a CSV file'
        messageType.value = 'error'
        return
      }

      const formData = new FormData()
      formData.append('file', csvImport.value.file)
      // The destination in this context is handled in backend logic, so it's not necessary
      // unless you want to differentiate between collection and kiosk imports for CSV

      try {
        const response = await axios.post('/api/collection/import_csv', formData, {
          headers: {
            'Content-Type': 'multipart/form-data'
          }
        })
        message.value = `CSV imported successfully: ${response.data.message}`
        messageType.value = 'success'
        // Reset form
        csvImport.value = { file: null, destination: 'collection' }
      } catch (error) {
        message.value = `Error importing CSV: ${error.response?.data?.error || error.message}`
        messageType.value = 'error'
      }
    }

    return {
      singleCard,
      csvImport,
      message,
      messageType,
      importSingleCard,
      handleFileUpload,
      importFromCSV
    }
  }
}
</script>

<style scoped>
.import-section {
  margin-bottom: 2rem;
}

form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  max-width: 400px;
  margin: 0 auto;
}

label {
  font-weight: bold;
}

input[type="text"],
input[type="number"],
select {
  width: 100%;
  padding: 0.5rem;
}

button {
  padding: 0.5rem 1rem;
  background-color: #4CAF50;
  color: white;
  border: none;
  cursor: pointer;
}

button:hover {
  background-color: #45a049;
}

.message {
  margin-top: 1rem;
  padding: 1rem;
  border-radius: 4px;
}

.success {
  background-color: #dff0d8;
  color: #3c763d;
}

.error {
  background-color: #f2dede;
  color: #a94442;
}
</style>

Explanation:

    Form Action: The CSV import form now sends the file to /api/collection/import_csv.

    FormData: Constructs FormData to send the file as multipart/form-data.

    Feedback: Displays success or error messages based on the response.

2.2. Enhance the Collection View to Filter by Set

We'll update the Collection.vue component to allow users to filter their collection by set (e.g., "Duskmourne").

Steps:

    Fetch Available Sets:

    Modify the Collection.vue to fetch all sets from the backend to populate the filter options.

    Update the API Call:

    Modify the API call to include the set filter.

    Update the Backend to Handle Set Filtering:

    Ensure the /api/collection endpoint can filter by set.

Updated Collection.vue:

vue

<!-- frontend/src/views/Collection.vue -->

<template>
  <div class="collection">
    <h1>My Collection</h1>
    <SetListControls
      :setTypes="setTypes"
      :totalPages="totalPages"
      @update-filters="updateFilters"
      @update-sorting="updateSorting"
      @update-per-page="updatePerPage"
    />
    <div class="additional-filters">
      <label for="setFilter">Filter by Set:</label>
      <select v-model="filters.set_code" @change="updateFilters" id="setFilter" class="select">
        <option value="">All Sets</option>
        <option v-for="set in availableSets" :key="set.code" :value="set.code">{{ set.name }}</option>
      </select>
    </div>
    <div v-if="loading" class="loading">Loading...</div>
    <div v-else-if="error" class="error">{{ error }}</div>
    <div v-else class="set-grid">
      <div v-for="set in sets" :key="set.code" class="set-card">
        <!-- Existing set display logic -->
      </div>
    </div>
    <div class="pagination">
      <button @click="changePage(-1)" :disabled="currentPage === 1">Previous</button>
      <span>Page {{ currentPage }} of {{ totalPages }}</span>
      <button @click="changePage(1)" :disabled="currentPage === totalPages">Next</button>
    </div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import axios from 'axios'
import SetListControls from '../components/SetListControls.vue'

export default {
  name: 'Collection',
  components: {
    SetListControls
  },
  setup() {
    const sets = ref([])
    const loading = ref(true)
    const error = ref(null)
    const filters = ref({ name: '', set_code: '' })
    const sorting = ref({ sortBy: 'released_at', sortOrder: 'desc' })
    const currentPage = ref(1)
    const totalPages = ref(1)
    const perPage = ref(20)
    const setTypes = ref([
      'core', 'expansion', 'masters', 'draft_innovation', 'funny',
      'starter', 'box', 'promo', 'token', 'memorabilia'
    ])
    const availableSets = ref([])

    const fetchAvailableSets = async () => {
      try {
        const response = await axios.get('/api/sets', {
          params: {
            per_page: 1000 // Assuming you have less than 1000 sets
          }
        })
        availableSets.value = response.data.sets
      } catch (err) {
        console.error('Error fetching sets:', err)
      }
    }

    const fetchSets = async () => {
      loading.value = true
      error.value = null
      try {
        const response = await axios.get('/api/collection', {
          params: {
            ...filters.value,
            ...sorting.value,
            page: currentPage.value,
            per_page: perPage.value
          }
        })
        sets.value = response.data.collection
        totalPages.value = response.data.pages
        currentPage.value = response.data.current_page
      } catch (err) {
        console.error('Error fetching collection:', err)
        error.value = 'Failed to load collection'
      } finally {
        loading.value = false
      }
    }

    const updateFilters = (newFilters) => {
      filters.value = { ...filters.value, ...newFilters }
      currentPage.value = 1
      fetchSets()
    }

    const updateSorting = (newSorting) => {
      sorting.value = { ...newSorting }
      fetchSets()
    }

    const updatePerPage = (newPerPage) => {
      perPage.value = newPerPage
      currentPage.value = 1
      fetchSets()
    }

    const changePage = (delta) => {
      const newPage = currentPage.value + delta
      if (newPage >= 1 && newPage <= totalPages.value) {
        currentPage.value = newPage
        fetchSets()
      }
    }

    const formatDate = (dateString) => {
      return new Date(dateString).toLocaleDateString()
    }

    onMounted(() => {
      fetchAvailableSets()
      fetchSets()
    })

    return {
      sets,
      loading,
      error,
      filters,
      sorting,
      currentPage,
      totalPages,
      perPage,
      setTypes,
      availableSets,
      updateFilters,
      updateSorting,
      updatePerPage,
      changePage,
      formatDate
    }
  }
}
</script>

<style scoped>
.collection {
  padding: 1rem;
}

.set-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 1rem;
}

.set-card {
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 1rem;
  text-align: center;
  background-color: #f9f9f9;
}

.set-icon {
  position: relative;
  width: 100px;
  height: 100px;
  margin: 0 auto 1rem;
}

.set-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.completion-circle {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: conic-gradient(
    #4CAF50 calc(var(--percentage) * 1%),
    #e0e0e0 calc(var(--percentage) * 1%)
  );
  opacity: 0.7;
}

.loading, .error {
  text-align: center;
  margin-top: 2rem;
  font-size: 1.2rem;
}

.pagination {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 2rem;
}

.pagination button {
  margin: 0 0.5rem;
  padding: 0.5rem 1rem;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.pagination button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.additional-filters {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.select {
  padding: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
}
</style>

Explanation:

    Fetching Available Sets: On component mount, fetch all available sets to populate the "Filter by Set" dropdown.

    Additional Filter: Adds a new dropdown to filter the collection by set code.

    API Integration: The fetchSets method now includes the set_code filter when making the API call.

2.3. Update the Backend to Handle Set Filtering in Collection

Ensure that the /api/collection endpoint can accept a set_code parameter to filter the collection accordingly.

Update collection_routes.py:

python

# backend/routes/collection_routes.py

@collection_routes.route('/collection', methods=['GET'])
def get_collection():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    set_code = request.args.get('set_code', '', type=str)

    query = Collection.query.join(Card).join(Set)

    if set_code:
        query = query.filter(Set.code == set_code)

    collection = query.paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'collection': [
            {
                **item.card.to_dict(),
                'quantity_regular': item.quantity_regular,
                'quantity_foil': item.quantity_foil
            }
            for item in collection.items
        ],
        'total': collection.total,
        'pages': collection.pages,
        'current_page': page
    }), 200

Explanation:

    Set Filtering: Adds a filter based on set_code if provided in the query parameters.

    Response Structure: Adjusts the response to include quantity_regular and quantity_foil directly within each card's data.

Note: Ensure that the to_dict method in the Card model includes necessary relationships. It already includes collection and kiosk, but adjust as needed based on the frontend's expectations.