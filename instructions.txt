Your backend is making significant progress toward merging the **`collections`** and **`kiosk`** tables into the **`cards`** table. However, based on the code snippets you've provided, there are a few critical areas that need attention to ensure a smooth and error-free transition. Let's analyze your current setup and outline the necessary steps to align your backend with the desired database schema changes.

---

## **1. Overview of Your Current Backend Structure**

### **A. Configuration and Initialization**

- **`config.py`**: Manages different environment configurations.
- **`database.py`**: Initializes SQLAlchemy and imports models.
- **`main.py`**: Sets up the Flask application, initializes extensions, registers routes, and defines the `/api/stats` endpoint.
- **`requirements.txt`**: Lists all required Python packages.
- **Models**:
  - **`card.py`**: Defines the `Card` model with new quantity fields.
  - **`set.py`**: Defines the `Set` model.
- **Routes**:
  - **`card_routes.py`**
  - **`collection_routes.py`** (Error: Missing file)
  - **`kiosk_routes.py`**
  - **`set_routes.py`**
- **`routes/__init__.py`**: Registers all route blueprints.

### **B. Observations**

1. **Missing Models**:
   - **`models/collection.py`**
   - **`models/kiosk.py`**

2. **Imports Pointing to Missing Models**:
   - **`database.py`**: Previously imported `Collection` and `Kiosk`, but you've removed these models.
   - **`main.py`**: Imports `Collection` and `Kiosk` models which no longer exist.
   - **`set.py`**: Imports `Collection` model, which is missing.
   - **`routes/__init__.py`**: Registers `collection_routes` and `kiosk_routes`, which may still reference the old models.

3. **Route Files Still Referencing Old Models**:
   - **`collection_routes.py`** and **`kiosk_routes.py`** still contain logic to interact with the now-merged tables.

---

## **2. Detailed Analysis and Recommendations**

### **A. Handling Missing Models and Imports**

Since you've decided to merge the **`collections`** and **`kiosk`** tables into the **`cards`** table, it's appropriate to remove the corresponding models. However, ensure that all parts of your application no longer depend on these models.

1. **Remove Imports from `database.py`**:

   **Current `database.py`:**
   ```python
   # database.py

   from flask_sqlalchemy import SQLAlchemy

   db = SQLAlchemy()

   # Import models here to avoid circular imports
   from models.card import Card
   from models.set import Set
   ```

   **Action**:
   - Ensure **`database.py`** no longer imports `Collection` and `Kiosk`.
   - It seems you've already done this based on the provided code.

2. **Update `main.py`**:

   **Current `main.py`:**
   ```python
   from routes import register_routes
   from routes.set_routes import set_routes
   from routes.kiosk_routes import kiosk_routes
   from routes.collection_routes import collection_routes
   from models.collection import Collection
   from models.kiosk import Kiosk
   from models.card import Card
   ```

   **Issues**:
   - Imports `Collection` and `Kiosk`, which no longer exist.

   **Action**:
   - **Remove** the following lines:
     ```python
     from models.collection import Collection
     from models.kiosk import Kiosk
     ```
   - Ensure that **`routes/collection_routes.py`** and **`routes/kiosk_routes.py`** are updated to reflect the new schema (more on this below).

3. **Update `set.py`**:

   **Current `set.py`:**
   ```python
   from models.collection import Collection
   from models.card import Card
   ```

   **Issues**:
   - Imports `Collection`, which is missing.

   **Action**:
   - **Remove** the import:
     ```python
     from models.collection import Collection
     ```
   - **Update** any references to `Collection` within `set.py` to use the new fields in the `Card` model.

4. **Update `routes/__init__.py`**:

   **Current `routes/__init__.py`:**
   ```python
   from .card_routes import card_routes
   from .set_routes import set_routes
   from .collection_routes import collection_routes
   from .kiosk_routes import kiosk_routes
   ```

   **Issues**:
   - If `collection_routes` and `kiosk_routes` are still referencing the old models, this will cause errors.

   **Action**:
   - **Ensure** that `collection_routes` and `kiosk_routes` are fully updated to work with the merged `cards` table.
   - **Alternatively**, if they are no longer needed as separate blueprints, consider consolidating their functionalities into `card_routes.py` or another appropriate blueprint.

### **B. Updating Route Files**

Both **`collection_routes.py`** and **`kiosk_routes.py`** need to be refactored to interact directly with the `cards` table instead of the separate `collections` and `kiosk` tables.

#### **1. Refactoring `collection_routes.py`**

**Current State**:
- References `Collection` model.
- Updates `Collection` entries based on card IDs.

**Issues**:
- The `Collection` model no longer exists.
- Needs to update the `Card` model's `quantity_collection_regular` and `quantity_collection_foil` fields directly.

**Refactored `collection_routes.py`:**

```python
import pandas as pd
from flask import Blueprint, jsonify, request, current_app
from sqlalchemy.orm import joinedload, load_only
from sqlalchemy.sql import func, asc, desc, text
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from models.card import Card
from models.set import Set
from database import db
import time
import logging
import orjson

collection_routes = Blueprint('collection_routes', __name__)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def serialize_collection(cards):
    return [{
        **card.to_dict(),
        'quantity_regular': card.quantity_collection_regular,
        'quantity_foil': card.quantity_collection_foil
    } for card in cards]

@collection_routes.route('/collection', methods=['GET'])
def get_collection():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    set_code = request.args.get('set_code', '', type=str)

    cache_key = f"collection:page:{page}:per_page:{per_page}:set_code:{set_code}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    query = Card.query

    if set_code:
        query = query.filter(Card.set_code == set_code)

    query = query.filter((Card.quantity_collection_regular > 0) | (Card.quantity_collection_foil > 0))

    collection = query.paginate(page=page, per_page=per_page, error_out=False)

    result = {
        'collection': serialize_collection(collection.items),
        'total': collection.total,
        'pages': collection.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@collection_routes.route('/collection/sets', methods=['GET'])
def get_collection_sets():
    try:
        name = request.args.get('name', type=str)
        set_type = request.args.get('set_type', type=str)
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        sort_by = request.args.get('sort_by', 'released_at', type=str)
        sort_order = request.args.get('sort_order', 'desc', type=str)

        cache_key = f"collection_sets:name:{name}:set_type:{set_type}:page:{page}:per_page:{per_page}:sort_by:{sort_by}:sort_order:{sort_order}"
        cached_data = current_app.redis_client.get(cache_key)

        if cached_data:
            return current_app.response_class(
                response=cached_data,
                status=200,
                mimetype='application/json'
            )

        logger.info(f"Received parameters: name={name}, set_type={set_type}, sort_by={sort_by}, sort_order={sort_order}, page={page}, per_page={per_page}")

        # Subquery to calculate collection_count per set_code
        subquery = db.session.query(
            Card.set_code.label('set_code'),
            func.sum(Card.quantity_collection_regular + Card.quantity_collection_foil).label('collection_count')
        ).group_by(Card.set_code).subquery()

        # Main query to fetch sets with their collection counts
        query = db.session.query(
            Set.id,
            Set.code,
            Set.name,
            Set.released_at,
            Set.set_type,
            Set.card_count,
            Set.digital,
            Set.foil_only,
            Set.icon_svg_uri,
            func.coalesce(subquery.c.collection_count, 0).label('collection_count')
        ).outerjoin(subquery, Set.code == subquery.c.set_code)

        if name:
            query = query.filter(Set.name.ilike(f'%{name}%'))
            logger.info(f"Applied filter: Set.name ilike '%{name}%'")
        if set_type:
            query = query.filter(Set.set_type == set_type)
            logger.info(f"Applied filter: Set.set_type == '{set_type}'")

        valid_sort_fields = {'released_at', 'name', 'collection_count', 'card_count'}
        if sort_by not in valid_sort_fields:
            error_message = f"Invalid sort_by field: {sort_by}"
            logger.error(error_message)
            return jsonify({"error": error_message}), 400

        if sort_by == 'collection_count':
            sort_column = subquery.c.collection_count
        else:
            sort_column = getattr(Set, sort_by)

        if sort_order.lower() == 'asc':
            query = query.order_by(asc(sort_column))
            logger.info(f"Sorting by {sort_by} in ascending order")
        else:
            query = query.order_by(desc(sort_column))
            logger.info(f"Sorting by {sort_by} in descending order")

        paginated_sets = query.paginate(page=page, per_page=per_page, error_out=False)
        logger.info(f"Paginated sets: page={paginated_sets.page}, pages={paginated_sets.pages}, total={paginated_sets.total}")

        sets_list = []
        for row in paginated_sets.items:
            set_data = {
                'id': row.id,
                'code': row.code,
                'name': row.name,
                'released_at': row.released_at,
                'set_type': row.set_type,
                'card_count': row.card_count,
                'digital': row.digital,
                'foil_only': row.foil_only,
                'icon_svg_uri': row.icon_svg_uri
            }
            collection_count = row.collection_count
            collection_percentage = (collection_count / row.card_count) * 100 if row.card_count else 0
            sets_list.append({
                **set_data,
                'collection_count': collection_count,
                'collection_percentage': collection_percentage
            })

        response = {
            'sets': sets_list,
            'total': paginated_sets.total,
            'pages': paginated_sets.pages,
            'current_page': paginated_sets.page
        }

        serialized_data = orjson.dumps(response)
        current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

        logger.info(f"Returning response with {len(sets_list)} sets")
        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        error_message = f"An unexpected error occurred: {str(e)}"
        logger.exception(error_message)
        return jsonify({"error": error_message}), 500

@collection_routes.route('/collection/<string:card_id>', methods=['POST', 'PUT'])
def update_collection(card_id):
    data = request.json
    quantity_regular = data.get('quantity_regular', 0)
    quantity_foil = data.get('quantity_foil', 0)

    card = Card.query.get(card_id)
    if not card:
        return jsonify({"error": "Card not found."}), 404

    card.quantity_collection_regular = quantity_regular
    card.quantity_collection_foil = quantity_foil

    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("collection:*")
    current_app.redis_client.delete("collection_sets:*")
    current_app.redis_client.delete("collection_stats")

    card_data = card.to_dict()
    card_data.update({
        'quantity_regular': card.quantity_collection_regular,
        'quantity_foil': card.quantity_collection_foil
    })

    return current_app.response_class(
        response=orjson.dumps(card_data),
        status=200,
        mimetype='application/json'
    )

@collection_routes.route('/collection/stats', methods=['GET'])
def get_collection_stats():
    cache_key = "collection_stats"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    try:
        total_cards = db.session.query(func.sum(Card.quantity_collection_regular + Card.quantity_collection_foil)).scalar() or 0
        unique_cards = Card.query.filter((Card.quantity_collection_regular > 0) | (Card.quantity_collection_foil > 0)).count()

        total_value_query = text("""
            SELECT SUM(
                (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * quantity_collection_regular) +
                (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * quantity_collection_foil)
            )
            FROM cards
            WHERE quantity_collection_regular > 0 OR quantity_collection_foil > 0
        """)
        total_value = db.session.execute(total_value_query).scalar() or 0

        result = {
            'total_cards': int(total_cards),
            'unique_cards': unique_cards,
            'total_value': round(total_value, 2)
        }

        serialized_data = orjson.dumps(result)
        current_app.redis_client.setex(cache_key, 3600, serialized_data)  # Cache for 1 hour

        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@collection_routes.route('/collection/sets/<string:set_code>/cards', methods=['GET'])
def get_collection_set_cards(set_code):
    name = request.args.get('name', '', type=str)
    rarity = request.args.get('rarity', '', type=str)
    colors = request.args.getlist('colors') + request.args.getlist('colors[]')

    try:
        # Build the query with only required columns using model attributes
        query = Card.query.options(
            load_only(
                Card.id,
                Card.name,
                Card.image_uris,
                Card.collector_number,
                Card.prices,
                Card.rarity,
                Card.set_name,
                Card.quantity_collection_regular,
                Card.quantity_collection_foil
            )
        ).filter(Card.set_code == set_code)

        # Apply filters
        if name:
            query = query.filter(Card.name.ilike(f'%{name}%'))
        if rarity:
            query = query.filter(Card.rarity == rarity)
        if colors:
            VALID_COLORS = {'W', 'U', 'B', 'R', 'G'}
            invalid_colors = set(colors) - VALID_COLORS
            if invalid_colors:
                return jsonify({"error": f"Invalid colors: {', '.join(invalid_colors)}"}), 400

            # Use JSONB array contains operator '?|'
            colors_str = "{" + ",".join(f'"{c}"' for c in colors) + "}"
            query = query.filter(text("cards.colors ?| :colors_str").bindparams(colors_str=colors_str))

        # Execute the query
        cards = query.all()

        # Prepare the response
        result = {
            'cards': [{
                'id': card.id,
                'name': card.name,
                'image_uris': card.image_uris,
                'collector_number': card.collector_number,
                'prices': card.prices,
                'rarity': card.rarity,
                'set_name': card.set_name,
                'quantity_regular': card.quantity_collection_regular,
                'quantity_foil': card.quantity_collection_foil
            } for card in cards],
            'total': len(cards),
        }

        return jsonify(result), 200
    except Exception as e:
        error_message = f"An unexpected error occurred: {str(e)}"
        logger.exception(error_message)
        return jsonify({"error": error_message}), 500

@collection_routes.route('/collection/import_csv', methods=['POST'])
def import_csv():
    if 'file' not in request.files:
        return jsonify({"error": "No file part in the request"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No file selected"}), 400

    if not file.filename.endswith('.csv'):
        return jsonify({"error": "Only CSV files are allowed"}), 400

    try:
        df = pd.read_csv(file)
    except Exception as e:
        logger.error(f"Failed to parse CSV: {str(e)}")
        return jsonify({"error": f"Failed to parse CSV: {str(e)}"}), 400

    required_columns = {
        'Name', 'Edition', 'Edition code', "Collector's number",
        'Price', 'Foil', 'Currency', 'Scryfall ID', 'Quantity'
    }
    if not required_columns.issubset(set(df.columns)):
        missing = required_columns - set(df.columns)
        return jsonify({"error": f"CSV is missing columns: {', '.join(missing)}"}), 400

    df['Foil'] = df['Foil'].fillna(False).replace('', False)

    try:
        with db.session.begin_nested():
            for index, row in df.iterrows():
                try:
                    process_csv_row(row, index)
                except ValueError as e:
                    logger.error(f"Error processing row {index + 2}: {str(e)}")
                    continue
                except IntegrityError as e:
                    logger.error(f"IntegrityError at row {index + 2}: {str(e)}")
                    db.session.rollback()
                    return jsonify({"error": f"Database integrity error at row {index + 2}: {str(e)}"}), 500

                if index % 100 == 0:
                    db.session.flush()

        db.session.commit()
        logger.info("CSV imported successfully")

        # Invalidate related caches
        current_app.redis_client.delete("collection:*")
        current_app.redis_client.delete("collection_sets:*")
        current_app.redis_client.delete("collection_stats")

        return jsonify({"message": "CSV imported successfully"}), 200

    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error(f"Database error during CSV import: {str(e)}")
        return jsonify({"error": f"Database error: {str(e)}"}), 500

def process_csv_row(row, index):
    scryfall_id = row['Scryfall ID']
    card_name = row['Name']

    try:
        quantity = int(row['Quantity'])
        if quantity < 1:
            raise ValueError(f"Invalid quantity for card '{card_name}' at row {index + 2}.")
    except ValueError:
        raise ValueError(f"Invalid quantity for card '{card_name}' at row {index + 2}.")

    foil = row['Foil']
    if isinstance(foil, bool):
        foil_status = foil
    else:
        raise ValueError(f"Foil value must be boolean for card '{card_name}' at row {index + 2}.")

    card = Card.query.filter_by(id=scryfall_id).first()
    if not card:
        raise ValueError(f"Card with Scryfall ID '{scryfall_id}' not found in the database.")

    if foil_status:
        card.quantity_collection_foil += quantity
    else:
        card.quantity_collection_regular += quantity

    db.session.add(card)
```

**Key Changes:**

1. **Removed References to `Collection` Model**:
   - Since `Collection` no longer exists, all references to it are removed.
   - Updated functions now interact directly with the `Card` model's `quantity_collection_regular` and `quantity_collection_foil` fields.

2. **Updated Serialization**:
   - The `serialize_collection` function now includes the updated quantity fields from the `Card` model.

3. **CSV Import Logic**:
   - The `process_csv_row` function directly updates the `Card` model's quantity fields based on the CSV input.

4. **Cache Invalidation**:
   - Updated cache keys to reflect changes in how collections are stored.

#### **2. Refactoring `kiosk_routes.py`**

Similarly, **`kiosk_routes.py`** needs to be refactored to interact directly with the `Card` model's kiosk-related fields.

**Refactored `kiosk_routes.py`:**

```python
from flask import Blueprint, jsonify, request, current_app
from models.card import Card
from models.set import Set
from database import db
from sqlalchemy.sql import func, text
from sqlalchemy import distinct
import orjson

kiosk_routes = Blueprint('kiosk_routes', __name__)

def serialize_sets(sets):
    return [set_obj.to_dict() for set_obj in sets]

def serialize_cards(cards):
    return [{
        **card.to_dict(),
        'quantity_regular': card.quantity_kiosk_regular,
        'quantity_foil': card.quantity_kiosk_foil
    } for card in cards]

@kiosk_routes.route('/kiosk', methods=['GET'])
def get_kiosk():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)

    cache_key = f"kiosk:page:{page}:per_page:{per_page}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    kiosk = Card.query.filter((Card.quantity_kiosk_regular > 0) | (Card.quantity_kiosk_foil > 0)).paginate(page=page, per_page=per_page, error_out=False)

    result = {
        'kiosk': serialize_cards(kiosk.items),
        'total': kiosk.total,
        'pages': kiosk.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/sets', methods=['GET'])
def get_kiosk_sets():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    sort_by = request.args.get('sortBy', 'released_at')
    sort_order = request.args.get('sortOrder', 'desc')

    cache_key = f"kiosk_sets:page:{page}:per_page:{per_page}:sort_by:{sort_by}:sort_order:{sort_order}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    kiosk_sets = db.session.query(Set).\
        join(Card, Card.set_code == Set.code).\
        filter((Card.quantity_kiosk_regular > 0) | (Card.quantity_kiosk_foil > 0)).\
        distinct()

    if sort_order == 'desc':
        kiosk_sets = kiosk_sets.order_by(getattr(Set, sort_by).desc())
    else:
        kiosk_sets = kiosk_sets.order_by(getattr(Set, sort_by))

    paginated_sets = kiosk_sets.paginate(page=page, per_page=per_page, error_out=False)

    sets_data = []
    for set_obj in paginated_sets.items:
        set_dict = set_obj.to_dict()

        kiosk_count = db.session.query(func.count(distinct(Card.id))).\
            filter(Card.set_code == set_obj.code).\
            filter((Card.quantity_kiosk_regular > 0) | (Card.quantity_kiosk_foil > 0)).\
            scalar()

        set_dict['kiosk_count'] = kiosk_count
        set_dict['kiosk_percentage'] = (kiosk_count / set_obj.card_count) * 100 if set_obj.card_count > 0 else 0

        sets_data.append(set_dict)

    result = {
        'sets': sets_data,
        'total': paginated_sets.total,
        'pages': paginated_sets.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 600, serialized_data)  # Cache for 10 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/sets/<string:set_code>/cards', methods=['GET'])
def get_kiosk_set_cards(set_code):
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    name_filter = request.args.get('name', '')
    rarity_filter = request.args.get('rarity', '')
    sort_by = request.args.get('sortBy', 'name')
    sort_order = request.args.get('sortOrder', 'asc')

    cache_key = f"kiosk_set_cards:{set_code}:page:{page}:per_page:{per_page}:name:{name_filter}:rarity:{rarity_filter}:sort_by:{sort_by}:sort_order:{sort_order}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    query = Card.query.filter(Card.set_code == set_code).filter(
        (Card.quantity_kiosk_regular > 0) | (Card.quantity_kiosk_foil > 0)
    )

    if name_filter:
        query = query.filter(Card.name.ilike(f'%{name_filter}%'))
    if rarity_filter:
        query = query.filter(Card.rarity == rarity_filter)

    if sort_order == 'desc':
        query = query.order_by(getattr(Card, sort_by).desc())
    else:
        query = query.order_by(getattr(Card, sort_by))

    paginated_cards = query.paginate(page=page, per_page=per_page, error_out=False)

    cards_data = serialize_cards(paginated_cards.items)

    set_instance = Set.query.filter_by(code=set_code).first()
    set_name = set_instance.name if set_instance else ''

    result = {
        'cards': cards_data,
        'set_name': set_name,
        'total': paginated_cards.total,
        'pages': paginated_cards.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/<string:card_id>', methods=['POST', 'PUT'])
def update_kiosk(card_id):
    data = request.json
    quantity_regular = data.get('quantity_regular', 0)
    quantity_foil = data.get('quantity_foil', 0)

    card = Card.query.get(card_id)
    if not card:
        return jsonify({"error": "Card not found."}), 404

    card.quantity_kiosk_regular = quantity_regular
    card.quantity_kiosk_foil = quantity_foil

    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("kiosk:*")
    current_app.redis_client.delete("kiosk_sets:*")
    current_app.redis_client.delete(f"kiosk_set_cards:{card.set_code}:*")

    # Serialize and return updated card
    card_data = card.to_dict()
    card_data.update({
        'quantity_regular': card.quantity_kiosk_regular,
        'quantity_foil': card.quantity_kiosk_foil
    })

    return current_app.response_class(
        response=orjson.dumps(card_data),
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/stats', methods=['GET'])
def get_kiosk_stats():
    cache_key = "kiosk_stats"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    try:
        total_cards = db.session.query(func.sum(Card.quantity_kiosk_regular + Card.quantity_kiosk_foil)).scalar() or 0
        unique_cards = Card.query.filter((Card.quantity_kiosk_regular > 0) | (Card.quantity_kiosk_foil > 0)).count()

        total_value_query = text("""
            SELECT SUM(
                (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * quantity_kiosk_regular) +
                (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * quantity_kiosk_foil)
            )
            FROM cards
            WHERE quantity_kiosk_regular > 0 OR quantity_kiosk_foil > 0
        """)
        total_value = db.session.execute(total_value_query).scalar() or 0

        result = {
            'total_cards': int(total_cards),
            'unique_cards': unique_cards,
            'total_value': round(total_value, 2)
        }

        serialized_data = orjson.dumps(result)
        current_app.redis_client.setex(cache_key, 3600, serialized_data)  # Cache for 1 hour

        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500
```

**Key Changes:**

1. **Removed References to `Kiosk` Model**:
   - Directly interacting with `Card` model's `quantity_kiosk_regular` and `quantity_kiosk_foil` fields.

2. **Serialization**:
   - Updated `serialize_cards` to include kiosk-related quantities.

3. **Cache Invalidation**:
   - Updated cache keys to reflect changes in how kiosk data is stored.

4. **Card Update Logic**:
   - The `update_kiosk` route directly updates the `Card` model's kiosk fields.

#### **3. Consolidating Blueprints (Optional but Recommended)**

Given that both **`collection_routes`** and **`kiosk_routes`** are now interacting with the **`Card`** model's quantity fields, you might consider consolidating these into a single blueprint (e.g., **`card_routes`**) to streamline your codebase. This reduces redundancy and makes maintenance easier.

**Example Consolidation:**

```python
# routes/card_routes.py

from flask import Blueprint, jsonify, request, current_app
from models.card import Card
from database import db
from sqlalchemy import or_, asc, desc, func, distinct, text
import orjson

card_routes = Blueprint('card_routes', __name__)

# Existing card routes...

# New routes for collection and kiosk can be added here
```

**Benefits:**

- **Reduced Redundancy**: Avoids having separate blueprints for collections and kiosks that essentially perform similar operations.
- **Easier Maintenance**: Changes to the `Card` model or related logic need to be made in only one place.

---

### **C. Refactoring `set.py`**

**Current `set.py`:**
```python
from models.collection import Collection
from models.card import Card

class Set(db.Model):
    __tablename__ = 'sets'

    id = db.Column(db.Text, primary_key=True)
    code = db.Column(db.Text, unique=True, nullable=False, index=True)
    name = db.Column(db.Text, nullable=False)
    released_at = db.Column(db.Text)
    set_type = db.Column(db.Text)
    card_count = db.Column(db.BigInteger)
    digital = db.Column(db.Boolean)
    foil_only = db.Column(db.Boolean)
    icon_svg_uri = db.Column(db.Text)

    # Relationships
    cards = db.relationship('Card', back_populates='set')

    def to_dict(self):
        collection_count = self.get_collection_count()
        collection_percentage = (collection_count / self.card_count) * 100 if self.card_count else 0
        return {
            'id': self.id,
            'code': self.code,
            'name': self.name,
            'released_at': self.released_at,
            'set_type': self.set_type,
            'card_count': self.card_count,
            'digital': self.digital,
            'foil_only': self.foil_only,
            'icon_svg_uri': self.icon_svg_uri,
            'collection_count': collection_count,
            'collection_percentage': collection_percentage
        }

    def get_collection_count(self):
        # Count the number of unique cards in the collection for this set
        return db.session.query(db.func.count(Collection.card_id)) \
            .join(Card, Card.id == Collection.card_id) \
            .filter(Card.set_code == self.code) \
            .scalar() or 0
```

**Issues:**

- **Imports `Collection` Model**: Since `Collection` has been removed, importing it will raise an `ImportError`.
- **`get_collection_count` Method**: Relies on the `Collection` model to count collected cards, which is no longer applicable.

**Refactored `set.py`:**

```python
from database import db
from models.card import Card

class Set(db.Model):
    __tablename__ = 'sets'

    id = db.Column(db.Text, primary_key=True)
    code = db.Column(db.Text, unique=True, nullable=False, index=True)
    name = db.Column(db.Text, nullable=False)
    released_at = db.Column(db.Text)
    set_type = db.Column(db.Text)
    card_count = db.Column(db.BigInteger)
    digital = db.Column(db.Boolean)
    foil_only = db.Column(db.Boolean)
    icon_svg_uri = db.Column(db.Text)

    # Relationships
    cards = db.relationship('Card', back_populates='set')

    def to_dict(self):
        collection_count = self.get_collection_count()
        collection_percentage = (collection_count / self.card_count) * 100 if self.card_count else 0
        return {
            'id': self.id,
            'code': self.code,
            'name': self.name,
            'released_at': self.released_at,
            'set_type': self.set_type,
            'card_count': self.card_count,
            'digital': self.digital,
            'foil_only': self.foil_only,
            'icon_svg_uri': self.icon_svg_uri,
            'collection_count': collection_count,
            'collection_percentage': collection_percentage
        }

    def get_collection_count(self):
        # Count the number of collected cards in this set
        return db.session.query(func.count(Card.id)) \
            .filter(Card.set_code == self.code) \
            .filter((Card.quantity_collection_regular > 0) | (Card.quantity_collection_foil > 0)) \
            .scalar() or 0
```

**Key Changes:**

1. **Removed Import of `Collection`**:
   - Eliminated `from models.collection import Collection`.

2. **Updated `get_collection_count` Method**:
   - Now counts collected cards directly from the `Card` model's quantity fields.
   - This avoids reliance on the removed `Collection` model.

---

### **D. Final Steps and Best Practices**

1. **Remove Unnecessary Files and References**:
   - Delete **`collection_routes.py`** and **`kiosk_routes.py`** if you decide to consolidate their functionalities.
   - Remove any remaining references to the `Collection` and `Kiosk` models throughout your codebase.

2. **Ensure Schema Consistency**:
   - Double-check that your **`cards`** table includes all necessary fields from the previously separate **`collections`** and **`kiosk`** tables.
   - Verify that relationships and foreign keys are correctly established, especially with the **`sets`** table.

3. **Update `routes/__init__.py`**:
   - If you've consolidated blueprints, update this file accordingly.
   - Example:
     ```python
     from flask import Blueprint
     from .card_routes import card_routes
     from .set_routes import set_routes

     def register_routes(app):
         api = Blueprint('api', __name__, url_prefix='/api')

         api.register_blueprint(card_routes)
         api.register_blueprint(set_routes)

         app.register_blueprint(api)

         @app.route('/')
         def index():
             return "Welcome to the MTG Collection Kiosk API"
     ```

4. **Comprehensive Testing**:
   - **Unit Tests**: Write or update unit tests for all modified routes to ensure they handle data correctly.
   - **Integration Tests**: Test interactions between different parts of your application to verify that data flows as expected.
   - **Manual Testing**: Use tools like **Postman** or **cURL** to manually test API endpoints.
   - **Edge Cases**: Test scenarios such as updating quantities to zero, handling non-existent card IDs, etc.

5. **Database Migrations**:
   - Consider using **Alembic** for managing future database migrations. This tool integrates seamlessly with SQLAlchemy and helps version control your schema changes.
   - **Setup Alembic**:
     ```bash
     pip install alembic
     alembic init alembic
     ```
   - **Configure Alembic** to work with your Flask application by updating **`alembic.ini`** and **`env.py`**.

6. **Update Documentation**:
   - Reflect the new database schema and API endpoints in your **`README.md`** or any other project documentation.
   - Provide clear instructions on how to interact with the updated API.

7. **Secure Your Application**:
   - Ensure that your **`SECRET_KEY`** and other sensitive environment variables are securely stored and not exposed in version control.
   - Use tools like **Flask-Talisman** to enhance security headers if necessary.

8. **Optimize Performance**:
   - Monitor your application's performance, especially after significant changes.
   - Utilize caching effectively to reduce database load.
   - Analyze and optimize SQL queries for efficiency.

---

## **3. Conclusion**

Your backend is on the right path toward merging the **`collections`** and **`kiosk`** tables into the **`cards`** table. However, to ensure a seamless transition, it's crucial to address the following:

1. **Remove All References to Deleted Models**: Ensure that no part of your codebase (including imports and route logic) references the now-removed **`Collection`** and **`Kiosk`** models.

2. **Update Route Logic**: Modify your API routes to interact directly with the `Card` model's new quantity fields instead of separate tables.

3. **Consolidate Blueprints**: Consider merging **`collection_routes`** and **`kiosk_routes`** into **`card_routes`** for better maintainability.

4. **Adjust Model Methods**: Update methods in models like `Set` to reflect the new schema, ensuring that all data manipulations are accurate.

5. **Thorough Testing**: Implement comprehensive testing to catch and resolve any issues arising from these changes.

6. **Documentation and Best Practices**: Keep your documentation updated and follow best practices to maintain a secure and efficient application.

By addressing these areas, you'll ensure that your backend remains robust, maintainable, and aligned with your project's evolving requirements. If you need further assistance with specific parts of the refactoring or encounter any issues during the process, feel free to ask!