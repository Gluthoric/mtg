=== backend/routes/collection_routes.py ===
import pandas as pd
from flask import Blueprint, jsonify, request, current_app
from sqlalchemy.orm import joinedload
from sqlalchemy.sql import func, asc, desc, text
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from models.collection import Collection
from models.card import Card
from models.kiosk import Kiosk
from models.set import Set
from database import db
import time
import logging
import orjson

collection_routes = Blueprint('collection_routes', __name__)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def serialize_collection(collection_items):
    return [{
        **item.card.to_dict(),
        'quantity_regular': item.quantity_regular,
        'quantity_foil': item.quantity_foil
    } for item in collection_items]

@collection_routes.route('/collection', methods=['GET'])
def get_collection():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    set_code = request.args.get('set_code', '', type=str)

    cache_key = f"collection:page:{page}:per_page:{per_page}:set_code:{set_code}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    query = Collection.query.join(Card).join(Set)

    if set_code:
        query = query.filter(Set.code == set_code)

    collection = query.paginate(page=page, per_page=per_page, error_out=False)

    result = {
        'collection': serialize_collection(collection.items),
        'total': collection.total,
        'pages': collection.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@collection_routes.route('/collection/sets', methods=['GET'])
def get_collection_sets():
    try:
        name = request.args.get('name', type=str)
        set_type = request.args.get('set_type', type=str)
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        sort_by = request.args.get('sort_by', 'released_at', type=str)
        sort_order = request.args.get('sort_order', 'desc', type=str)

        cache_key = f"collection_sets:name:{name}:set_type:{set_type}:page:{page}:per_page:{per_page}:sort_by:{sort_by}:sort_order:{sort_order}"
        cached_data = current_app.redis_client.get(cache_key)

        if cached_data:
            return current_app.response_class(
                response=cached_data,
                status=200,
                mimetype='application/json'
            )

        logger.info(f"Received parameters: name={name}, set_type={set_type}, sort_by={sort_by}, sort_order={sort_order}, page={page}, per_page={per_page}")

        # Subquery to calculate collection_count per set_code
        subquery = db.session.query(
            Card.set_code.label('set_code'),
            func.count(Collection.card_id).label('collection_count')
        ).outerjoin(Collection, Collection.card_id == Card.id
        ).group_by(Card.set_code).subquery()

        # Main query to fetch sets with their collection counts
        query = db.session.query(
            Set.id,
            Set.code,
            Set.name,
            Set.released_at,
            Set.set_type,
            Set.card_count,
            Set.digital,
            Set.foil_only,
            Set.icon_svg_uri,
            func.coalesce(subquery.c.collection_count, 0).label('collection_count')
        ).outerjoin(subquery, Set.code == subquery.c.set_code)

        if name:
            query = query.filter(Set.name.ilike(f'%{name}%'))
            logger.info(f"Applied filter: Set.name ilike '%{name}%'")
        if set_type:
            query = query.filter(Set.set_type == set_type)
            logger.info(f"Applied filter: Set.set_type == '{set_type}'")

        valid_sort_fields = {'released_at', 'name', 'collection_count', 'card_count'}
        if sort_by not in valid_sort_fields:
            error_message = f"Invalid sort_by field: {sort_by}"
            logger.error(error_message)
            return jsonify({"error": error_message}), 400

        if sort_by == 'collection_count':
            sort_column = subquery.c.collection_count
        else:
            sort_column = getattr(Set, sort_by)

        if sort_order.lower() == 'asc':
            query = query.order_by(asc(sort_column))
            logger.info(f"Sorting by {sort_by} in ascending order")
        else:
            query = query.order_by(desc(sort_column))
            logger.info(f"Sorting by {sort_by} in descending order")

        paginated_sets = query.paginate(page=page, per_page=per_page, error_out=False)
        logger.info(f"Paginated sets: page={paginated_sets.page}, pages={paginated_sets.pages}, total={paginated_sets.total}")

        sets_list = []
        for row in paginated_sets.items:
            set_data = {
                'id': row.id,
                'code': row.code,
                'name': row.name,
                'released_at': row.released_at,
                'set_type': row.set_type,
                'card_count': row.card_count,
                'digital': row.digital,
                'foil_only': row.foil_only,
                'icon_svg_uri': row.icon_svg_uri
            }
            collection_count = row.collection_count
            collection_percentage = (collection_count / row.card_count) * 100 if row.card_count else 0
            sets_list.append({
                **set_data,
                'collection_count': collection_count,
                'collection_percentage': collection_percentage
            })

        response = {
            'sets': sets_list,
            'total': paginated_sets.total,
            'pages': paginated_sets.pages,
            'current_page': paginated_sets.page
        }

        serialized_data = orjson.dumps(response)
        current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

        logger.info(f"Returning response with {len(sets_list)} sets")
        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        error_message = f"An unexpected error occurred: {str(e)}"
        logger.exception(error_message)
        return jsonify({"error": error_message}), 500

@collection_routes.route('/collection/<string:card_id>', methods=['POST', 'PUT'])
def update_collection(card_id):
    data = request.json
    quantity_regular = data.get('quantity_regular', 0)
    quantity_foil = data.get('quantity_foil', 0)

    collection_item = Collection.query.filter_by(card_id=card_id).first()

    if collection_item:
        collection_item.quantity_regular = quantity_regular
        collection_item.quantity_foil = quantity_foil
    else:
        collection_item = Collection(card_id=card_id, quantity_regular=quantity_regular, quantity_foil=quantity_foil)
        db.session.add(collection_item)

    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("collection:*")
    current_app.redis_client.delete("collection_sets:*")
    current_app.redis_client.delete("collection_stats")

    card = Card.query.filter_by(id=card_id).first()
    if not card:
        return jsonify({"error": "Card not found."}), 404

    card_data = card.to_dict()
    card_data.update({
        'quantity_regular': collection_item.quantity_regular,
        'quantity_foil': collection_item.quantity_foil
    })

    return current_app.response_class(
        response=orjson.dumps(card_data),
        status=200,
        mimetype='application/json'
    )

@collection_routes.route('/collection/<string:card_id>', methods=['DELETE'])
def remove_from_collection(card_id):
    collection_item = Collection.query.filter_by(card_id=card_id).first_or_404()
    db.session.delete(collection_item)
    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("collection:*")
    current_app.redis_client.delete("collection_sets:*")
    current_app.redis_client.delete("collection_stats")

    return '', 204

@collection_routes.route('/collection/stats', methods=['GET'])
def get_collection_stats():
    try:
        cache_key = "collection_stats"
        cached_data = current_app.redis_client.get(cache_key)

        if cached_data:
            return current_app.response_class(
                response=cached_data,
                status=200,
                mimetype='application/json'
            )

        total_cards = db.session.query(func.sum(Collection.quantity_regular + Collection.quantity_foil)).scalar() or 0
        unique_cards = Collection.query.count()

        total_value_query = text("""
            SELECT SUM(
                (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * collections.quantity_regular) +
                (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * collections.quantity_foil)
            )
            FROM collections
            JOIN cards ON cards.id = collections.card_id
        """)
        total_value = db.session.execute(total_value_query).scalar() or 0

        result = {
            'total_cards': int(total_cards),
            'unique_cards': unique_cards,
            'total_value': round(total_value, 2)
        }

        serialized_data = orjson.dumps(result)
        current_app.redis_client.setex(cache_key, 3600, serialized_data)  # Cache for 1 hour

        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@collection_routes.route('/collection/sets/<string:set_code>/cards', methods=['GET'])
def get_collection_set_cards(set_code):
    name = request.args.get('name', '', type=str)
    rarity = request.args.get('rarity', '', type=str)
    colors = request.args.getlist('colors') + request.args.getlist('colors[]')

    try:
        query = Card.query.outerjoin(Collection).join(Set).filter(Set.code == set_code)

        if name:
            query = query.filter(Card.name.ilike(f'%{name}%'))
        if rarity:
            query = query.filter(Card.rarity == rarity)
        if colors:
            VALID_COLORS = {'W', 'U', 'B', 'R', 'G'}
            invalid_colors = set(colors) - VALID_COLORS
            if invalid_colors:
                return jsonify({"error": f"Invalid colors: {', '.join(invalid_colors)}"}), 400

            colors_str = "{" + ",".join(f'"{c}"' for c in colors) + "}"
            query = query.filter(text("cards.colors ?| :colors_str").bindparams(colors_str=colors_str))

        # Log the SQL query
        logger.info(f"Executing query: {query}")

        cards = query.all()

        # Log the number of cards returned
        logger.info(f"Number of cards returned: {len(cards)}")

        result = {
            'cards': [{
                **card.to_dict(),
                'quantity_regular': card.collection.quantity_regular if card.collection else 0,
                'quantity_foil': card.collection.quantity_foil if card.collection else 0
            } for card in cards],
            'total': len(cards),
        }

        # Log the first few cards for debugging
        logger.info(f"First 5 cards: {result['cards'][:5]}")

        return jsonify(result), 200
    except Exception as e:
        error_message = f"An unexpected error occurred: {str(e)}"
        logger.exception(error_message)
        return jsonify({"error": error_message}), 500

@collection_routes.route('/collection/import_csv', methods=['POST'])
def import_csv():
    if 'file' not in request.files:
        return jsonify({"error": "No file part in the request"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No file selected"}), 400

    if not file.filename.endswith('.csv'):
        return jsonify({"error": "Only CSV files are allowed"}), 400

    try:
        df = pd.read_csv(file)
    except Exception as e:
        logger.error(f"Failed to parse CSV: {str(e)}")
        return jsonify({"error": f"Failed to parse CSV: {str(e)}"}), 400

    required_columns = {
        'Name', 'Edition', 'Edition code', "Collector's number",
        'Price', 'Foil', 'Currency', 'Scryfall ID', 'Quantity'
    }
    if not required_columns.issubset(set(df.columns)):
        missing = required_columns - set(df.columns)
        return jsonify({"error": f"CSV is missing columns: {', '.join(missing)}"}), 400

    df['Foil'] = df['Foil'].fillna(False).replace('', False)

    try:
        with db.session.begin_nested():
            for index, row in df.iterrows():
                try:
                    process_csv_row(row, index)
                except ValueError as e:
                    logger.error(f"Error processing row {index + 2}: {str(e)}")
                    continue
                except IntegrityError as e:
                    logger.error(f"IntegrityError at row {index + 2}: {str(e)}")
                    db.session.rollback()
                    return jsonify({"error": f"Database integrity error at row {index + 2}: {str(e)}"}), 500

                if index % 100 == 0:
                    db.session.flush()

        db.session.commit()
        logger.info("CSV imported successfully")

        # Invalidate related caches
        current_app.redis_client.delete("collection:*")
        current_app.redis_client.delete("collection_sets:*")
        current_app.redis_client.delete("collection_stats")

        return jsonify({"message": "CSV imported successfully"}), 200

    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error(f"Database error during CSV import: {str(e)}")
        return jsonify({"error": f"Database error: {str(e)}"}), 500

def process_csv_row(row, index):
    scryfall_id = row['Scryfall ID']
    card_name = row['Name']

    try:
        quantity = int(row['Quantity'])
        if quantity < 1:
            raise ValueError(f"Invalid quantity for card '{card_name}' at row {index + 2}.")
    except ValueError:
        raise ValueError(f"Invalid quantity for card '{card_name}' at row {index + 2}.")

    foil = row['Foil']
    if isinstance(foil, bool):
        foil_status = foil
    else:
        raise ValueError(f"Foil value must be boolean for card '{card_name}' at row {index + 2}.")

    card = Card.query.filter_by(id=scryfall_id).first()
    if not card:
        raise ValueError(f"Card with Scryfall ID '{scryfall_id}' not found in the database.")

    collection_item = Collection.query.filter_by(card_id=card.id).first()
    kiosk_item = Kiosk.query.filter_by(card_id=card.id).first()

    if foil_status:
        handle_foil_card(card, quantity, collection_item, kiosk_item)
    else:
        handle_non_foil_card(card, quantity, collection_item, kiosk_item)

def handle_foil_card(card, quantity, collection_item, kiosk_item):
    if collection_item and collection_item.quantity_foil > 0:
        if kiosk_item:
            kiosk_item.quantity_foil += quantity
        else:
            kiosk_item = Kiosk(card_id=card.id, quantity_foil=quantity)
            db.session.add(kiosk_item)
    else:
        to_collection = 1 if quantity >= 1 else 0
        to_kiosk = quantity - to_collection

        if to_collection > 0:
            if collection_item:
                collection_item.quantity_foil += to_collection
            else:
                collection_item = Collection(card_id=card.id, quantity_foil=to_collection)
                db.session.add(collection_item)

        if to_kiosk > 0:
            if kiosk_item:
                kiosk_item.quantity_foil += to_kiosk
            else:
                kiosk_item = Kiosk(card_id=card.id, quantity_foil=to_kiosk)
                db.session.add(kiosk_item)

def handle_non_foil_card(card, quantity, collection_item, kiosk_item):
    has_collection_copy = collection_item and (collection_item.quantity_regular > 0 or collection_item.quantity_foil > 0)

    if not has_collection_copy:
        to_collection = 1 if quantity >= 1 else 0
        to_kiosk = quantity - to_collection

        if to_collection > 0:
            if collection_item:
                collection_item.quantity_regular += to_collection
            else:
                collection_item = Collection(card_id=card.id, quantity_regular=to_collection)
                db.session.add(collection_item)

        if to_kiosk > 0:
            if kiosk_item:
                kiosk_item.quantity_regular += to_kiosk
            else:
                kiosk_item = Kiosk(card_id=card.id, quantity_regular=to_kiosk)
                db.session.add(kiosk_item)
    else:
        if kiosk_item:
            kiosk_item.quantity_regular += quantity
        else:
            kiosk_item = Kiosk(card_id=card.id, quantity_regular=quantity)
            db.session.add(kiosk_item)


=== database_information.txt ===
| info_type    | info                                    |
| ------------ | --------------------------------------- |
| Columns      | cards - arena_id (bigint)               |
| Columns      | cards - artist (text)                   |
| Columns      | cards - artist_ids (jsonb)              |
| Columns      | cards - booster (boolean)               |
| Columns      | cards - border_color (text)             |
| Columns      | cards - card_back_id (text)             |
| Columns      | cards - cmc (double precision)          |
| Columns      | cards - collector_number (text)         |
| Columns      | cards - color_identity (jsonb)          |
| Columns      | cards - colors (jsonb)                  |
| Columns      | cards - digital (boolean)               |
| Columns      | cards - finishes (jsonb)                |
| Columns      | cards - foil (boolean)                  |
| Columns      | cards - frame (text)                    |
| Columns      | cards - full_art (boolean)              |
| Columns      | cards - games (jsonb)                   |
| Columns      | cards - highres_image (boolean)         |
| Columns      | cards - id (text)                       |
| Columns      | cards - illustration_id (text)          |
| Columns      | cards - image_status (text)             |
| Columns      | cards - image_uris (jsonb)              |
| Columns      | cards - keywords (jsonb)                |
| Columns      | cards - lang (text)                     |
| Columns      | cards - layout (text)                   |
| Columns      | cards - legalities (jsonb)              |
| Columns      | cards - mana_cost (text)                |
| Columns      | cards - mtgo_id (bigint)                |
| Columns      | cards - multiverse_ids (text)           |
| Columns      | cards - name (text)                     |
| Columns      | cards - nonfoil (boolean)               |
| Columns      | cards - oracle_id (text)                |
| Columns      | cards - oracle_text (text)              |
| Columns      | cards - oversized (boolean)             |
| Columns      | cards - prices (jsonb)                  |
| Columns      | cards - produced_mana (jsonb)           |
| Columns      | cards - promo (boolean)                 |
| Columns      | cards - purchase_uris (text)            |
| Columns      | cards - rarity (text)                   |
| Columns      | cards - related_uris (jsonb)            |
| Columns      | cards - released_at (text)              |
| Columns      | cards - reprint (boolean)               |
| Columns      | cards - reserved (boolean)              |
| Columns      | cards - scryfall_uri (text)             |
| Columns      | cards - set_code (text)                 |
| Columns      | cards - set_name (text)                 |
| Columns      | cards - story_spotlight (boolean)       |
| Columns      | cards - tcgplayer_id (bigint)           |
| Columns      | cards - textless (boolean)              |
| Columns      | cards - type_line (text)                |
| Columns      | cards - uri (text)                      |
| Columns      | cards - variation (boolean)             |
| Columns      | collections - card_id (text)            |
| Columns      | collections - id (bigint)               |
| Columns      | collections - quantity_foil (bigint)    |
| Columns      | collections - quantity_regular (bigint) |
| Columns      | kiosk - card_id (text)                  |
| Columns      | kiosk - id (bigint)                     |
| Columns      | kiosk - quantity_foil (bigint)          |
| Columns      | kiosk - quantity_regular (bigint)       |
| Columns      | sets - card_count (bigint)              |
| Columns      | sets - code (text)                      |
| Columns      | sets - digital (boolean)                |
| Columns      | sets - foil_only (boolean)              |
| Columns      | sets - icon_svg_uri (text)              |
| Columns      | sets - id (text)                        |
| Columns      | sets - name (text)                      |
| Columns      | sets - released_at (text)               |
| Columns      | sets - set_type (text)                  |
| Primary Keys | cards - id                              |
| Tables       | cards                                   |
| Tables       | collections                             |
| Tables       | kiosk                                   |
| Tables       | sets                                    |

=== frontend/src/views/Collection.vue ===
<template>
  <div class="container mx-auto px-4 bg-dark-300 text-white">
    <h1 class="text-center mb-4 text-2xl font-bold text-primary">My Collection</h1>
    <SetListControls
      :setTypes="setTypes"
      :totalPages="totalPages"
      @update-filters="updateFilters"
      @update-sorting="updateSorting"
      @update-per-page="updatePerPage"
      class="controls bg-secondary p-4 rounded-lg shadow-md mb-4"
    />
    <div v-if="loading" class="loading text-center mt-1">Loading...</div>
    <div v-else-if="error" class="error text-center mt-1">{{ error }}</div>
    <div v-else-if="sets && sets.length > 0" class="set-grid grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4">
      <div v-for="set in sets" :key="set.code" class="card bg-secondary p-4 rounded-lg shadow-md transition-transform hover:scale-105">
        <router-link :to="{ name: 'CollectionSetCards', params: { setCode: set.code } }">
          <!-- Set icon displayed at the top -->
          <div class="set-icon">
            <img :src="set.icon_svg_uri" :alt="set.name" />
          </div>

          <!-- Set code and name in a compact format -->
          <h3 class="text-center">{{ set.code.toUpperCase() }} - {{ set.name }}</h3>

          <!-- Display the Collection card count -->
          <p class="text-center">Collection: {{ set.collection_count }} / {{ set.card_count }}</p>

          <!-- Display the completion percentage -->
          <p class="text-center">Completion: {{ Math.round(set.collection_percentage) }}%</p>

          <!-- Add a progress bar for visual representation -->
          <div class="progress-container">
            <div
              class="progress-bar"
              :style="{ width: `${set.collection_percentage}%`, backgroundColor: getProgressColor(set.collection_percentage) }"
            ></div>
          </div>
        </router-link>
      </div>
    </div>
    <div v-else-if="!loading && sets.length === 0" class="text-center mt-1">
      <p>No sets found in your collection.</p>
    </div>
    <div class="pagination flex justify-center items-center mt-4 space-x-4">
      <button 
        @click="changePage(-1)" 
        :disabled="currentPage === 1"
        class="px-4 py-2 bg-primary text-white rounded-md disabled:opacity-50 disabled:cursor-not-allowed"
      >
        Previous
      </button>
      <span class="text-lg font-semibold">Page {{ currentPage }} of {{ totalPages }}</span>
      <button 
        @click="changePage(1)" 
        :disabled="currentPage === totalPages"
        class="px-4 py-2 bg-primary text-white rounded-md disabled:opacity-50 disabled:cursor-not-allowed"
      >
        Next
      </button>
    </div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import axios from 'axios'
import SetListControls from '../components/SetListControls.vue'

export default {
  name: 'Collection',
  components: {
    SetListControls
  },
  setup() {
    const sets = ref([])
    const loading = ref(true)
    const error = ref(null)
    const filters = ref({})
    const sorting = ref({ sortBy: 'released_at', sortOrder: 'desc' })
    const currentPage = ref(1)
    const totalPages = ref(1)
    const perPage = ref(20)
    const setTypes = ref([
      'core', 'expansion', 'masters', 'draft_innovation', 'funny',
      'starter', 'box', 'promo', 'token', 'memorabilia'
    ])

    const fetchSets = async () => {
      loading.value = true
      error.value = null
      try {
        const response = await axios.get('/api/collection/sets', {
          params: {
            ...filters.value,
            ...sorting.value,
            page: currentPage.value,
            per_page: perPage.value
          }
        })
        sets.value = response.data.sets
        totalPages.value = response.data.pages
        currentPage.value = response.data.current_page
      } catch (err) {
        console.error('Error fetching collection sets:', err)
        error.value = 'Failed to load collection sets'
      } finally {
        loading.value = false
      }
    }

    const updateFilters = (newFilters) => {
      filters.value = { ...filters.value, ...newFilters }
      currentPage.value = 1
      fetchSets()
    }

    const updateSorting = (newSorting) => {
      sorting.value = { ...newSorting }
      fetchSets()
    }

    const updatePerPage = (newPerPage) => {
      perPage.value = newPerPage
      currentPage.value = 1
      fetchSets()
    }

    const changePage = (delta) => {
      const newPage = currentPage.value + delta
      if (newPage >= 1 && newPage <= totalPages.value) {
        currentPage.value = newPage
        fetchSets()
      }
    }

    const formatDate = (dateString) => {
      return new Date(dateString).toLocaleDateString()
    }

    const getProgressColor = (percentage) => {
      if (percentage < 25) return '#f44336'
      if (percentage < 50) return '#ff9800'
      if (percentage < 75) return '#ffc107'
      return '#4caf50'
    }

    onMounted(() => {
      fetchSets()
    })

    return {
      sets,
      loading,
      error,
      filters,
      sorting,
      currentPage,
      totalPages,
      perPage,
      setTypes,
      updateFilters,
      updateSorting,
      updatePerPage,
      changePage,
      formatDate,
      getProgressColor
    }
  }
}
</script>

<style scoped>
.controls {
  background-color: var(--secondary-color);
  padding: 1rem;
  border-radius: 0.5rem;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.grid {
  display: grid;
  gap: 1rem;
}

@media (min-width: 768px) {
  .grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (min-width: 1024px) {
  .grid {
    grid-template-columns: repeat(4, 1fr);
  }
}

input, select {
  width: 100%;
  padding: 0.5rem;
  border: 1px solid var(--border-color);
  border-radius: 0.25rem;
}

input:focus, select:focus {
  outline: none;
  box-shadow: 0 0 0 2px var(--primary-color);
}

.card {
  padding: 1rem;
  background-color: var(--secondary-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  transition: transform 0.3s ease;
}

.card:hover {
  transform: scale(1.02);
}

.set-icon {
  width: 50px;
  height: 50px;
  margin: 0 auto 1rem;
}

.set-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.progress-container {
  width: 100%;
  background-color: #e0e0e0;
  border-radius: 4px;
  overflow: hidden;
  margin-top: 0.5rem;
}

.progress-bar {
  height: 8px;
  transition: width 0.3s ease;
}
</style>


=== frontend/src/views/CollectionSetCards.vue ===
<template>
  <div class="container mx-auto px-4 bg-dark-300 text-white">
    <h1 class="text-center mb-4 text-2xl font-bold text-primary">{{ setName }}</h1>
    <div v-if="loading" class="loading text-center mt-4">Loading...</div>
    <div v-else-if="error" class="error text-center mt-4 text-red-500">{{ error }}</div>
    <div v-else>
      <CardListControls
        :filters="filters"
        :cardsPerRow="cardsPerRow"
        @update-filters="updateFilters"
        @update-cards-per-row="updateCardsPerRow"
      />

      <!-- Cards Grid -->
      <div class="card-grid grid gap-6" :style="gridStyle">
        <div
          v-for="card in filteredAndSortedCards"
          :key="card.id"
          class="card bg-dark-200 shadow-md rounded-lg overflow-hidden relative flex flex-col"
          :class="{ 'border-2 border-red-500': isMissing(card) }"
          :style="{ width: '100%', maxWidth: `${cardSize * 1.2}px` }"
        >
          <div class="card-info p-2 z-10 bg-dark-200 bg-opacity-80">
            <h3 class="text-base font-semibold truncate text-primary">{{ card.name }}</h3>
          </div>
          <div class="image-container" :style="{ height: `${cardSize * 1.4}px` }">
            <img
              v-if="getImageUrl(card)"
              :src="getImageUrl(card)"
              :alt="card.name"
              class="w-full h-full object-contain"
              @error="handleImageError($event, card)"
            />
            <div v-else class="w-full h-full flex items-center justify-center bg-dark-100 text-gray-medium">
              No image available
            </div>
          </div>
          <div class="card-info p-2 flex flex-col">
            <div class="flex justify-between items-center mb-2">
              <p class="text-xs text-gray-light">CN: {{ card.collector_number }}</p>
              <p class="text-xs text-gray-light">{{ card.rarity }}</p>
            </div>
            <div class="card-quantities flex flex-col space-y-2">
              <!-- Regular Quantity Control -->
              <div class="quantity-control">
                <label :for="'regular-' + card.id" class="quantity-label text-xs font-semibold text-gray-light block mb-1">
                  Regular
                </label>
                <div class="input-wrapper flex items-center justify-center border rounded-md overflow-hidden">
                  <button
                    @click="decrement(card, 'regular')"
                    class="btn decrement-btn flex items-center justify-center bg-dark-300 hover:bg-dark-400"
                    aria-label="Decrement Regular Quantity"
                    :disabled="card.quantity_regular === 0"
                  >
                    –
                  </button>
                  <input
                    :id="'regular-' + card.id"
                    v-model.number="card.quantity_regular"
                    type="number"
                    min="0"
                    class="quantity-input text-center border-none outline-none bg-dark-100 text-white text-sm"
                    @input="onInput(card, 'regular')"
                  />
                  <button
                    @click="increment(card, 'regular')"
                    class="btn increment-btn flex items-center justify-center bg-dark-300 hover:bg-dark-400"
                    aria-label="Increment Regular Quantity"
                  >
                    +
                  </button>
                </div>
                <div class="price text-xs text-gray-light mt-1">
                  Price: ${{ card.prices?.usd || 'N/A' }}
                </div>
              </div>

              <!-- Foil Quantity Control -->
              <div class="quantity-control">
                <label :for="'foil-' + card.id" class="quantity-label text-xs font-semibold text-gray-light block mb-1">
                  Foil
                </label>
                <div class="input-wrapper flex items-center justify-center border rounded-md overflow-hidden">
                  <button
                    @click="decrement(card, 'foil')"
                    class="btn decrement-btn w-8 h-8 flex items-center justify-center bg-dark-300 hover:bg-dark-400"
                    aria-label="Decrement Foil Quantity"
                    :disabled="card.quantity_foil === 0"
                  >
                    –
                  </button>
                  <input
                    :id="'foil-' + card.id"
                    v-model.number="card.quantity_foil"
                    type="number"
                    min="0"
                    class="quantity-input w-12 h-8 text-center border-none outline-none bg-dark-100 text-white text-sm"
                    @input="onInput(card, 'foil')"
                  />
                  <button
                    @click="increment(card, 'foil')"
                    class="btn increment-btn w-8 h-8 flex items-center justify-center bg-dark-300 hover:bg-dark-400"
                    aria-label="Increment Foil Quantity"
                  >
                    +
                  </button>
                </div>
                <div class="price text-xs text-gray-light mt-1">
                  Price: ${{ card.prices?.usd_foil || 'N/A' }}
                </div>
              </div>
            </div>
          </div>
          <div v-if="isMissing(card)" class="missing-indicator absolute top-1 right-1 bg-red-500 text-white px-2 py-1 rounded text-xs font-bold shadow">
            Missing
          </div>
        </div>
      </div>

      <!-- Handle No Cards Matching Filters -->
      <div v-if="filteredAndSortedCards.length === 0" class="text-center text-gray-light">
        No cards match the selected filters.
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, watch, computed } from 'vue';
import axios from 'axios';
import { useRoute } from 'vue-router';
import qs from 'qs';  // Import qs for query string serialization
import CardListControls from '../components/CardListControls.vue';

export default {
  name: 'CollectionSetCards',
  components: {
    CardListControls
  },
  setup() {
    const route = useRoute();
    const setCode = ref(route.params.setCode);
    const setName = ref('');
    const cards = ref([]);
    const loading = ref(true);
    const error = ref(null);
    const filters = ref({
      name: '',
      rarity: '',
      colors: [],
      missing: false
    });
    const cardsPerRow = ref(6);
    const cardSize = 180;

    const fetchCards = async () => {
      loading.value = true;
      error.value = null;
      try {
        const params = {
          ...filters.value,
          colors: filters.value.colors // Send colors as array
        };

        const response = await axios.get(`/api/collection/sets/${setCode.value}/cards`, {
          params,
          paramsSerializer: params => qs.stringify(params, { arrayFormat: 'repeat' }) // Serialize as colors=W&colors=U
        });
        cards.value = response.data.cards;
        setName.value = cards.value.length > 0 ? cards.value[0].set_name : '';
      } catch (err) {
        console.error('Error fetching set cards:', err);
        error.value = 'Failed to load set cards';
      } finally {
        loading.value = false;
      }
    };

    const updateFilters = (newFilters) => {
      filters.value = { ...filters.value, ...newFilters };
      fetchCards();
    };

    const updateCardsPerRow = (newCardsPerRow) => {
      cardsPerRow.value = newCardsPerRow;
    };

    watch(
      () => route.params.setCode,
      (newSetCode) => {
        setCode.value = newSetCode;
        fetchCards();
      }
    );

    onMounted(() => {
      fetchCards();
    });

    const isMissing = (card) => {
      return card.quantity_regular + card.quantity_foil === 0;
    };

    const filteredAndSortedCards = computed(() => {
      return cards.value
        .filter(card => {
          if (filters.value.missing) {
            return card.quantity_regular === 0 && card.quantity_foil === 0;
          }
          return true;
        })
        .sort((a, b) => {
          if (!a.collector_number && !b.collector_number) return 0;
          if (!a.collector_number) return 1;
          if (!b.collector_number) return -1;

          const numA = parseInt(a.collector_number, 10);
          const numB = parseInt(b.collector_number, 10);

          if (!isNaN(numA) && !isNaN(numB)) {
            return numA - numB;
          }
          return a.collector_number.localeCompare(b.collector_number);
        });
    });

    const getImageUrl = (card) => {
      const imageSizes = ['normal', 'large', 'small', 'png', 'art_crop', 'border_crop'];

      if (card.image_uris) {
        for (const size of imageSizes) {
          if (card.image_uris[size]) {
            return card.image_uris[size];
          }
        }
      }

      if (card.card_faces && card.card_faces[0].image_uris) {
        for (const size of imageSizes) {
          if (card.card_faces[0].image_uris[size]) {
            return card.card_faces[0].image_uris[size];
          }
        }
      }

      console.warn('No image URL found for card:', card.name);
      return null;
    };

    const handleImageError = (event, card) => {
      console.error('Image failed to load for card:', card.name, 'URL:', event.target.src);
      event.target.style.display = 'none';
      const noImageDiv = event.target.parentNode.querySelector('.bg-dark-100');
      if (noImageDiv) {
        noImageDiv.style.display = 'flex';
      }
    };

    const updateQuantity = async (card) => {
      try {
        const response = await axios.put(`/api/collection/${card.id}`, {
          quantity_regular: card.quantity_regular,
          quantity_foil: card.quantity_foil,
        });
        const index = cards.value.findIndex((c) => c.id === card.id);
        if (index !== -1) {
          cards.value[index] = response.data;
        }
      } catch (err) {
        console.error('Error updating quantity:', err);
        alert('Failed to update quantity. Please try again.');
      }
    };

    const increment = (card, type) => {
      if (type === 'regular') {
        card.quantity_regular += 1;
      } else if (type === 'foil') {
        card.quantity_foil += 1;
      }
      updateQuantity(card);
    };

    const decrement = (card, type) => {
      if (type === 'regular' && card.quantity_regular > 0) {
        card.quantity_regular -= 1;
        updateQuantity(card);
      } else if (type === 'foil' && card.quantity_foil > 0) {
        card.quantity_foil -= 1;
        updateQuantity(card);
      }
    };

    const onInput = (card, type) => {
      if (type === 'regular') {
        card.quantity_regular = Math.max(0, parseInt(card.quantity_regular) || 0);
      } else if (type === 'foil') {
        card.quantity_foil = Math.max(0, parseInt(card.quantity_foil) || 0);
      }
      updateQuantity(card);
    };

    const gridStyle = computed(() => ({
      gridTemplateColumns: `repeat(${cardsPerRow.value}, 1fr)`,
    }));

    return {
      setName,
      cards,
      loading,
      error,
      filters,
      updateFilters,
      isMissing,
      filteredAndSortedCards,
      getImageUrl,
      handleImageError,
      increment,
      decrement,
      onInput,
      cardsPerRow,
      updateCardsPerRow,
      gridStyle,
      cardSize,
    };
  },
};
</script>

<style scoped>
.card {
  display: flex;
  flex-direction: column;
  transition: transform 0.2s ease-in-out;
  width: 100%;
  height: 100%;
  justify-content: space-between;
}

.card-info {
  padding: 0.75rem;
}

.image-container {
  width: 100%;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
}

.image-container img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}
.card {
  display: flex;
  flex-direction: column;
  transition: transform 0.2s ease-in-out;
  width: 100%;
}

.card:hover {
  transform: scale(1.02);
}

.card-info {
  flex-grow: 0;
}

.card-quantities {
  display: flex;
  justify-content: space-between;
}

.image-container {
  width: 100%;
  overflow: hidden;
  aspect-ratio: 5 / 7;
}

.quantity-control {
  width: 48%;
}

.quantity-label {
  font-size: 0.75rem;
}

.quantity-input {
  -webkit-appearance: textfield;
  -moz-appearance: textfield;
  appearance: textfield;
}

.quantity-input::-webkit-inner-spin-button,
.quantity-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.buttons button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.missing-indicator {
  position: absolute;
  top: 8px;
  right: 8px;
  background-color: red;
  color: white;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: bold;
  box-shadow: 0 0 5px rgba(0,0,0,0.3);
}

input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 8px;
  background: #4a5568;
  outline: none;
  opacity: 0.7;
  transition: opacity 0.2s;
  border-radius: 5px;
}

input[type="range"]:hover {
  opacity: 1;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: #4299e1;
  cursor: pointer;
  border-radius: 50%;
}

input[type="range"]::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: #4299e1;
  cursor: pointer;
  border-radius: 50%;
}

.quantity-control {
  width: 100%;
}

.input-wrapper {
  width: 100%;
  max-width: 120px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
}

.quantity-input {
  flex: 1;
  min-width: 0;
}

.btn {
  flex-shrink: 0;
  width: 24px;
  min-width: 24px;
}

@media (max-width: 640px) {
  .card-quantities {
    flex-direction: column;
  }

  .quantity-control {
    margin-bottom: 0.5rem;
  }
}

/* New styles for color labels */
.text-white {
  color: white;
}
.text-blue-500 {
  color: #4299e1; /* Tailwind CSS blue-500 */
}
.text-black {
  color: black;
}
.text-red-500 {
  color: #f56565; /* Tailwind CSS red-500 */
}
.text-green-500 {
  color: #48bb78; /* Tailwind CSS green-500 */
}
</style>
