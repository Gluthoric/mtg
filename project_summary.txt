== Start of backend/config.py ==
import os
from dotenv import load_dotenv

# Load environment variables from the .env file
load_dotenv()

class Config:
    # The base configuration class that other environments will inherit from
    SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URI')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SECRET_KEY = os.getenv('SECRET_KEY')

class DevelopmentConfig(Config):
    # Development-specific settings
    DEBUG = True

class TestingConfig(Config):
    # Testing-specific settings
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.getenv('TEST_DATABASE_URI')

class ProductionConfig(Config):
    # Production-specific settings
    DEBUG = False

# Map configuration names to their corresponding config classes
config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
== End of backend/config.py ==

== Start of backend/database.py ==
# Database initialization and models

from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

# Import models here to avoid circular imports
from models.card import Card
from models.set import Set
from models.collection import Collection
from models.kiosk import Kiosk
== End of backend/database.py ==

== Start of backend/main.py ==
from flask import Flask
from flask_cors import CORS
from config import Config
from database import db
from routes import register_routes
from routes.set_routes import set_routes

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)

    # Initialize extensions
    db.init_app(app)
    CORS(app)

    # Register routes
    register_routes(app)
    app.register_blueprint(set_routes, url_prefix='/api')

    return app

if __name__ == '__main__':
    app = create_app()
    app.run(debug=True)
== End of backend/main.py ==

== Start of backend/models/card.py ==
from database import db
from sqlalchemy.dialects.postgresql import JSONB

class Card(db.Model):
    __tablename__ = 'cards'

    id = db.Column(db.Text, primary_key=True)
    oracle_id = db.Column(db.Text, index=True)
    multiverse_ids = db.Column(JSONB)
    mtgo_id = db.Column(db.BigInteger)
    arena_id = db.Column(db.BigInteger)
    tcgplayer_id = db.Column(db.BigInteger)
    name = db.Column(db.Text, nullable=False, index=True)
    lang = db.Column(db.Text)
    released_at = db.Column(db.Text)
    uri = db.Column(db.Text)
    scryfall_uri = db.Column(db.Text)
    layout = db.Column(db.Text)
    highres_image = db.Column(db.Boolean)
    image_status = db.Column(db.Text)
    image_uris = db.Column(JSONB)
    mana_cost = db.Column(db.Text)
    cmc = db.Column(db.Float)
    type_line = db.Column(db.Text, index=True)
    oracle_text = db.Column(db.Text)
    colors = db.Column(JSONB)
    color_identity = db.Column(JSONB)
    keywords = db.Column(JSONB)
    produced_mana = db.Column(JSONB)
    legalities = db.Column(JSONB)
    games = db.Column(JSONB)
    reserved = db.Column(db.Boolean)
    foil = db.Column(db.Boolean)
    nonfoil = db.Column(db.Boolean)
    finishes = db.Column(JSONB)
    oversized = db.Column(db.Boolean)
    promo = db.Column(db.Boolean)
    reprint = db.Column(db.Boolean)
    variation = db.Column(db.Boolean)
    set_code = db.Column(db.Text, db.ForeignKey('sets.code'), index=True)
    set_name = db.Column(db.Text)
    collector_number = db.Column(db.Text)
    digital = db.Column(db.Boolean)
    rarity = db.Column(db.Text, index=True)
    card_back_id = db.Column(db.Text)
    artist = db.Column(db.Text)
    artist_ids = db.Column(JSONB)
    illustration_id = db.Column(db.Text)
    border_color = db.Column(db.Text)
    frame = db.Column(db.Text)
    full_art = db.Column(db.Boolean)
    textless = db.Column(db.Boolean)
    booster = db.Column(db.Boolean)
    story_spotlight = db.Column(db.Boolean)
    prices = db.Column(JSONB)
    related_uris = db.Column(JSONB)
    purchase_uris = db.Column(JSONB)

    # Relationships
    set = db.relationship('Set', back_populates='cards')
    collection = db.relationship('Collection', back_populates='card', uselist=False, cascade='all, delete-orphan')
    kiosk = db.relationship('Kiosk', back_populates='card', uselist=False, cascade='all, delete-orphan')

    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'set_name': self.set_name,
            'set_code': self.set_code,
            'collector_number': self.collector_number,
            'type_line': self.type_line,
            'rarity': self.rarity,
            'mana_cost': self.mana_cost,
            'cmc': self.cmc,
            'oracle_text': self.oracle_text,
            'colors': self.colors,
            'image_uris': self.image_uris,
            'prices': self.prices,
            'collection': self.collection.to_dict() if self.collection else None,
            'kiosk': self.kiosk.to_dict() if self.kiosk else None
        }
== End of backend/models/card.py ==

== Start of backend/models/collection.py ==
from database import db

class Collection(db.Model):
    __tablename__ = 'collections'

    id = db.Column(db.BigInteger, primary_key=True, autoincrement=True)
    card_id = db.Column(db.Text, db.ForeignKey('cards.id'), nullable=False)
    quantity_regular = db.Column(db.BigInteger, default=0)
    quantity_foil = db.Column(db.BigInteger, default=0)

    # Relationship
    card = db.relationship('Card', back_populates='collection')

    def to_dict(self):
        return {
            'id': self.id,
            'card_id': self.card_id,
            'quantity_regular': self.quantity_regular,
            'quantity_foil': self.quantity_foil
        }
== End of backend/models/collection.py ==

== Start of backend/models/kiosk.py ==
from database import db

class Kiosk(db.Model):
    __tablename__ = 'kiosk'

    id = db.Column(db.BigInteger, primary_key=True, autoincrement=True)
    card_id = db.Column(db.Text, db.ForeignKey('cards.id'), nullable=False)
    quantity_regular = db.Column(db.BigInteger, default=0)
    quantity_foil = db.Column(db.BigInteger, default=0)

    # Relationship
    card = db.relationship('Card', back_populates='kiosk')

    def to_dict(self):
        return {
            'id': self.id,
            'card_id': self.card_id,
            'quantity_regular': self.quantity_regular,
            'quantity_foil': self.quantity_foil
        }
== End of backend/models/kiosk.py ==

== Start of backend/models/set.py ==
from database import db
from models.collection import Collection
from models.card import Card

class Set(db.Model):
    __tablename__ = 'sets'

    id = db.Column(db.Text, primary_key=True)
    code = db.Column(db.Text, unique=True, nullable=False, index=True)
    name = db.Column(db.Text, nullable=False)
    released_at = db.Column(db.Text)
    set_type = db.Column(db.Text)
    card_count = db.Column(db.BigInteger)
    digital = db.Column(db.Boolean)
    foil_only = db.Column(db.Boolean)
    icon_svg_uri = db.Column(db.Text)

    # Relationships
    cards = db.relationship('Card', back_populates='set')

    def to_dict(self):
        collection_count = self.get_collection_count()
        collection_percentage = (collection_count / self.card_count) * 100 if self.card_count else 0
        return {
            'id': self.id,
            'code': self.code,
            'name': self.name,
            'released_at': self.released_at,
            'set_type': self.set_type,
            'card_count': self.card_count,
            'digital': self.digital,
            'foil_only': self.foil_only,
            'icon_svg_uri': self.icon_svg_uri,
            'collection_count': collection_count,
            'collection_percentage': collection_percentage
        }

    def get_collection_count(self):
        # Count the number of unique cards in the collection for this set
        return db.session.query(db.func.count(Collection.card_id)) \
            .join(Card, Card.id == Collection.card_id) \
            .filter(Card.set_code == self.code) \
            .scalar() or 0
== End of backend/models/set.py ==

== Start of backend/routes/__init__.py ==
from flask import Blueprint
from .card_routes import card_routes
from .set_routes import set_routes
from .collection_routes import collection_routes
from .kiosk_routes import kiosk_routes

def register_routes(app):
    api = Blueprint('api', __name__, url_prefix='/api')

    api.register_blueprint(card_routes)
    api.register_blueprint(set_routes)
    api.register_blueprint(collection_routes)
    api.register_blueprint(kiosk_routes)

    app.register_blueprint(api)

    @app.route('/')
    def index():
        return "Welcome to the MTG Collection Kiosk API"
== End of backend/routes/__init__.py ==

== Start of backend/routes/card_routes.py ==
from flask import Blueprint, jsonify, request
from models.card import Card
from database import db
from sqlalchemy import or_

card_routes = Blueprint('card_routes', __name__)

@card_routes.route('/cards', methods=['GET'])
def get_cards():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    name = request.args.get('name', '')
    set_code = request.args.get('set_code', '')
    rarity = request.args.get('rarity', '')
    colors = request.args.get('colors', '').split(',') if request.args.get('colors') else []

    query = Card.query

    if name:
        query = query.filter(Card.name.ilike(f'%{name}%'))
    if set_code:
        query = query.filter(Card.set_code == set_code)
    if rarity:
        query = query.filter(Card.rarity == rarity)
    if colors:
        query = query.filter(or_(*[Card.colors.contains([color]) for color in colors]))

    cards = query.paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'cards': [card.to_dict() for card in cards.items],
        'total': cards.total,
        'pages': cards.pages,
        'current_page': page
    }), 200

@card_routes.route('/cards/<string:card_id>', methods=['GET'])
def get_card(card_id):
    card = Card.query.get_or_404(card_id)
    return jsonify(card.to_dict()), 200

@card_routes.route('/cards/search', methods=['GET'])
def search_cards():
    query = request.args.get('q', '')
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)

    cards = Card.query.filter(
        or_(
            Card.name.ilike(f'%{query}%'),
            Card.type_line.ilike(f'%{query}%'),
            Card.oracle_text.ilike(f'%{query}%')
        )
    ).paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'cards': [card.to_dict() for card in cards.items],
        'total': cards.total,
        'pages': cards.pages,
        'current_page': page
    }), 200
== End of backend/routes/card_routes.py ==

== Start of backend/routes/collection_routes.py ==
import pandas as pd
from flask import Blueprint, jsonify, request
from models.collection import Collection
from models.card import Card
from models.kiosk import Kiosk
from models.set import Set
from database import db
from sqlalchemy.sql import func, asc, desc, text
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
import logging

collection_routes = Blueprint('collection_routes', __name__)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@collection_routes.route('/collection', methods=['GET'])
def get_collection():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    set_code = request.args.get('set_code', '', type=str)

    query = Collection.query.join(Card).join(Set)

    if set_code:
        query = query.filter(Set.code == set_code)

    collection = query.paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'collection': [
            {
                **item.card.to_dict(),
                'quantity_regular': item.quantity_regular,
                'quantity_foil': item.quantity_foil
            }
            for item in collection.items
        ],
        'total': collection.total,
        'pages': collection.pages,
        'current_page': page
    }), 200

@collection_routes.route('/collection/sets', methods=['GET'])
def get_collection_sets():
    try:
        diagnostic_info = {
            "set_count": Set.query.count(),
            "collection_count": Collection.query.count(),
            "card_count": Card.query.count(),
            "step1_count": 0,
            "step2_count": 0,
            "step3_count": 0,
            "total_count_before_pagination": 0
        }

        # Extract query parameters
        name = request.args.get('name', type=str, default='')
        set_type = request.args.get('set_type', type=str, default='')
        sort_by = request.args.get('sort_by', type=str, default='released_at')
        sort_order = request.args.get('sort_order', type=str, default='desc')
        page = request.args.get('page', type=int, default=1)
        per_page = request.args.get('per_page', type=int, default=20)

        logger.info(f"Received parameters: name={name}, set_type={set_type}, sort_by={sort_by}, sort_order={sort_order}, page={page}, per_page={per_page}")

        # Base query with specific columns and collection count using outer joins
        query = db.session.query(
            Set.id,
            Set.code,
            Set.name,
            Set.released_at,
            Set.set_type,
            Set.card_count,
            Set.digital,
            Set.foil_only,
            Set.icon_svg_uri,
            func.count(Collection.card_id).label('collection_count')
        ).outerjoin(Card, Card.set_code == Set.code
        ).outerjoin(Collection, Collection.card_id == Card.id
        ).group_by(
            Set.id,
            Set.code,
            Set.name,
            Set.released_at,
            Set.set_type,
            Set.card_count,
            Set.digital,
            Set.foil_only,
            Set.icon_svg_uri
        )

        # Step 1: After joining Set and Card
        diagnostic_info["step1_count"] = query.count()

        # Step 2: After joining with Collection
        diagnostic_info["step2_count"] = query.count()

        # Step 3: After grouping
        diagnostic_info["step3_count"] = query.count()

        # Apply filters
        if name:
            query = query.filter(Set.name.ilike(f'%{name}%'))
            logger.info(f"Applied filter: Set.name ilike '%{name}%'")
        if set_type:
            query = query.filter(Set.set_type == set_type)
            logger.info(f"Applied filter: Set.set_type == '{set_type}'")

        # Validate and apply sorting
        valid_sort_fields = {'released_at', 'name', 'collection_count', 'card_count'}
        if sort_by not in valid_sort_fields:
            error_message = f"Invalid sort_by field: {sort_by}"
            logger.error(error_message)
            return jsonify({"error": error_message, "diagnostic_info": diagnostic_info}), 400

        if sort_by == 'collection_count':
            sort_column = func.count(Collection.card_id)
        else:
            sort_column = getattr(Set, sort_by)

        if sort_order.lower() == 'asc':
            query = query.order_by(asc(sort_column))
            logger.info(f"Sorting by {sort_by} in ascending order")
        else:
            query = query.order_by(desc(sort_column))
            logger.info(f"Sorting by {sort_by} in descending order")

        # Get total count before pagination
        total_count = query.count()
        diagnostic_info["total_count_before_pagination"] = total_count
        logger.info(f"Total count before pagination: {total_count}")

        # Apply pagination
        paginated_sets = query.paginate(page=page, per_page=per_page, error_out=False)
        logger.info(f"Paginated sets: page={paginated_sets.page}, pages={paginated_sets.pages}, total={paginated_sets.total}")

        # Build response
        sets_list = []
        for row in paginated_sets.items:
            set_data = {
                'id': row.id,
                'code': row.code,
                'name': row.name,
                'released_at': row.released_at,
                'set_type': row.set_type,
                'card_count': row.card_count,
                'digital': row.digital,
                'foil_only': row.foil_only,
                'icon_svg_uri': row.icon_svg_uri
            }
            collection_count = row.collection_count
            collection_percentage = (collection_count / row.card_count) * 100 if row.card_count else 0
            sets_list.append({
                **set_data,
                'collection_count': collection_count,
                'collection_percentage': collection_percentage
            })

        response = {
            'sets': sets_list,
            'total': paginated_sets.total,
            'pages': paginated_sets.pages,
            'current_page': paginated_sets.page,
            'diagnostic_info': diagnostic_info
        }

        logger.info(f"Returning response with {len(sets_list)} sets")
        return jsonify(response), 200
    except Exception as e:
        error_message = f"An unexpected error occurred: {str(e)}"
        logger.exception(error_message)
        return jsonify({"error": error_message, "diagnostic_info": diagnostic_info}), 500

@collection_routes.route('/collection/<string:card_id>', methods=['POST', 'PUT'])
def update_collection(card_id):
    data = request.json
    quantity_regular = data.get('quantity_regular', 0)
    quantity_foil = data.get('quantity_foil', 0)

    collection_item = Collection.query.filter_by(card_id=card_id).first()

    if collection_item:
        collection_item.quantity_regular = quantity_regular
        collection_item.quantity_foil = quantity_foil
    else:
        collection_item = Collection(card_id=card_id, quantity_regular=quantity_regular, quantity_foil=quantity_foil)
        db.session.add(collection_item)

    db.session.commit()

    return jsonify(collection_item.to_dict()), 200

@collection_routes.route('/collection/<string:card_id>', methods=['DELETE'])
def remove_from_collection(card_id):
    collection_item = Collection.query.filter_by(card_id=card_id).first_or_404()
    db.session.delete(collection_item)
    db.session.commit()

    return '', 204

@collection_routes.route('/collection/stats', methods=['GET'])
def get_collection_stats():
    try:
        total_cards = db.session.query(func.sum(Collection.quantity_regular + Collection.quantity_foil)).scalar() or 0
        unique_cards = Collection.query.count()

        # Use a raw SQL query to calculate the total value
        total_value_query = text("""
            SELECT SUM(
                (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * collections.quantity_regular) +
                (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * collections.quantity_foil)
            )
            FROM collections
            JOIN cards ON cards.id = collections.card_id
        """)
        total_value = db.session.execute(total_value_query).scalar() or 0

        return jsonify({
            'total_cards': int(total_cards),
            'unique_cards': unique_cards,
            'total_value': round(total_value, 2)
        }), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@collection_routes.route('/collection/sets/<string:set_code>/cards', methods=['GET'])
def get_collection_set_cards(set_code):
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    name = request.args.get('name', '', type=str)
    rarity = request.args.get('rarity', '', type=str)

    query = Collection.query.join(Card).join(Set).filter(Set.code == set_code)

    if name:
        query = query.filter(Card.name.ilike(f'%{name}%'))
    if rarity:
        query = query.filter(Card.rarity == rarity)

    collection = query.paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'cards': [
            {
                **item.card.to_dict(),
                'quantity_regular': item.quantity_regular,
                'quantity_foil': item.quantity_foil
            }
            for item in collection.items
        ],
        'total': collection.total,
        'pages': collection.pages,
        'current_page': page
    }), 200

@collection_routes.route('/collection/import_csv', methods=['POST'])
def import_csv():
    if 'file' not in request.files:
        return jsonify({"error": "No file part in the request"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No file selected"}), 400

    if not file.filename.endswith('.csv'):
        return jsonify({"error": "Only CSV files are allowed"}), 400

    try:
        df = pd.read_csv(file)
    except Exception as e:
        logger.error(f"Failed to parse CSV: {str(e)}")
        return jsonify({"error": f"Failed to parse CSV: {str(e)}"}), 400

    required_columns = {
        'Name', 'Edition', 'Edition code', "Collector's number",
        'Price', 'Foil', 'Currency', 'Scryfall ID', 'Quantity'
    }
    if not required_columns.issubset(set(df.columns)):
        missing = required_columns - set(df.columns)
        return jsonify({"error": f"CSV is missing columns: {', '.join(missing)}"}), 400

    # **New Code Starts Here**
    # Replace blank 'Foil' values with False
    df['Foil'] = df['Foil'].fillna(False)          # Replace NaN with False
    df['Foil'] = df['Foil'].replace('', False)    # Replace empty strings with False
    # **New Code Ends Here**

    try:
        with db.session.begin_nested():
            for index, row in df.iterrows():
                try:
                    process_csv_row(row, index)
                except ValueError as e:
                    logger.error(f"Error processing row {index + 2}: {str(e)}")
                    # Optionally, collect errors to return after processing
                    continue  # Skip to the next row
                except IntegrityError as e:
                    logger.error(f"IntegrityError at row {index + 2}: {str(e)}")
                    db.session.rollback()
                    return jsonify({"error": f"Database integrity error at row {index + 2}: {str(e)}"}), 500

                # Flush every 100 rows to catch potential errors earlier
                if index % 100 == 0:
                    db.session.flush()

        db.session.commit()
        logger.info("CSV imported successfully")
        return jsonify({"message": "CSV imported successfully"}), 200

    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error(f"Database error during CSV import: {str(e)}")
        return jsonify({"error": f"Database error: {str(e)}"}), 500

def process_csv_row(row, index):
    scryfall_id = row['Scryfall ID']
    card_name = row['Name']

    # Validate and parse quantity
    try:
        quantity = int(row['Quantity'])
        if quantity < 1:
            raise ValueError(f"Invalid quantity for card '{card_name}' at row {index + 2}.")
    except ValueError:
        raise ValueError(f"Invalid quantity for card '{card_name}' at row {index + 2}.")

    # Normalize foil value
    foil = row['Foil']
    if isinstance(foil, bool):
        foil_status = foil
    else:
        # This should not happen as we've already replaced blanks with False
        raise ValueError(f"Foil value must be boolean for card '{card_name}' at row {index + 2}.")

    # Fetch the card from the database
    card = Card.query.filter_by(id=scryfall_id).first()
    if not card:
        raise ValueError(f"Card with Scryfall ID '{scryfall_id}' not found in the database.")

    # Fetch or create collection and kiosk entries
    collection_item = Collection.query.filter_by(card_id=card.id).first()
    kiosk_item = Kiosk.query.filter_by(card_id=card.id).first()

    if foil_status:
        handle_foil_card(card, quantity, collection_item, kiosk_item)
    else:
        handle_non_foil_card(card, quantity, collection_item, kiosk_item)

def handle_foil_card(card, quantity, collection_item, kiosk_item):
    if collection_item and collection_item.quantity_foil > 0:
        if kiosk_item:
            kiosk_item.quantity_foil += quantity
        else:
            kiosk_item = Kiosk(card_id=card.id, quantity_foil=quantity)
            db.session.add(kiosk_item)
    else:
        to_collection = 1 if quantity >= 1 else 0
        to_kiosk = quantity - to_collection

        if to_collection > 0:
            if collection_item:
                collection_item.quantity_foil += to_collection
            else:
                collection_item = Collection(card_id=card.id, quantity_foil=to_collection)
                db.session.add(collection_item)

        if to_kiosk > 0:
            if kiosk_item:
                kiosk_item.quantity_foil += to_kiosk
            else:
                kiosk_item = Kiosk(card_id=card.id, quantity_foil=to_kiosk)
                db.session.add(kiosk_item)

def handle_non_foil_card(card, quantity, collection_item, kiosk_item):
    has_collection_copy = collection_item and (collection_item.quantity_regular > 0 or collection_item.quantity_foil > 0)

    if not has_collection_copy:
        to_collection = 1 if quantity >= 1 else 0
        to_kiosk = quantity - to_collection

        if to_collection > 0:
            if collection_item:
                collection_item.quantity_regular += to_collection
            else:
                collection_item = Collection(card_id=card.id, quantity_regular=to_collection)
                db.session.add(collection_item)

        if to_kiosk > 0:
            if kiosk_item:
                kiosk_item.quantity_regular += to_kiosk
            else:
                kiosk_item = Kiosk(card_id=card.id, quantity_regular=to_kiosk)
                db.session.add(kiosk_item)
    else:
        if kiosk_item:
            kiosk_item.quantity_regular += quantity
        else:
            kiosk_item = Kiosk(card_id=card.id, quantity_regular=quantity)
            db.session.add(kiosk_item)

== End of backend/routes/collection_routes.py ==

== Start of backend/routes/kiosk_routes.py ==
from flask import Blueprint, jsonify, request
from models.kiosk import Kiosk
from models.card import Card
from database import db
from sqlalchemy.sql import func, text

kiosk_routes = Blueprint('kiosk_routes', __name__)

@kiosk_routes.route('/kiosk', methods=['GET'])
def get_kiosk():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)

    kiosk = Kiosk.query.join(Card).paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'kiosk': [
            {**item.card.to_dict(), 'quantity': item.to_dict()}
            for item in kiosk.items
        ],
        'total': kiosk.total,
        'pages': kiosk.pages,
        'current_page': page
    }), 200

@kiosk_routes.route('/kiosk/<string:card_id>', methods=['POST', 'PUT'])
def update_kiosk(card_id):
    data = request.json
    quantity_regular = data.get('quantity_regular', 0)
    quantity_foil = data.get('quantity_foil', 0)

    kiosk_item = Kiosk.query.filter_by(card_id=card_id).first()

    if kiosk_item:
        kiosk_item.quantity_regular = quantity_regular
        kiosk_item.quantity_foil = quantity_foil
    else:
        kiosk_item = Kiosk(card_id=card_id, quantity_regular=quantity_regular, quantity_foil=quantity_foil)
        db.session.add(kiosk_item)

    db.session.commit()

    return jsonify(kiosk_item.to_dict()), 200

@kiosk_routes.route('/kiosk/<string:card_id>', methods=['DELETE'])
def remove_from_kiosk(card_id):
    kiosk_item = Kiosk.query.filter_by(card_id=card_id).first_or_404()
    db.session.delete(kiosk_item)
    db.session.commit()

    return '', 204

@kiosk_routes.route('/kiosk/stats', methods=['GET'])
def get_kiosk_stats():
    try:
        total_cards = db.session.query(func.sum(Kiosk.quantity_regular + Kiosk.quantity_foil)).scalar() or 0
        unique_cards = Kiosk.query.count()

        # Use a raw SQL query to calculate the total value
        total_value_query = text("""
            SELECT SUM(
                (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * kiosk.quantity_regular) +
                (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * kiosk.quantity_foil)
            )
            FROM kiosk
            JOIN cards ON cards.id = kiosk.card_id
        """)
        total_value = db.session.execute(total_value_query).scalar() or 0

        return jsonify({
            'total_cards': int(total_cards),
            'unique_cards': unique_cards,
            'total_value': round(total_value, 2)
        }), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500
== End of backend/routes/kiosk_routes.py ==

== Start of backend/routes/set_routes.py ==
from flask import Blueprint, jsonify, request
from models.set import Set
from models.card import Card
from database import db
from sqlalchemy import asc, desc

set_routes = Blueprint('set_routes', __name__)

@set_routes.route('/sets', methods=['GET'])
def get_all_sets():
    try:
        # Extract query parameters
        name = request.args.get('name', type=str, default='')
        set_type = request.args.get('set_type', type=str, default='')
        sort_by = request.args.get('sort_by', type=str, default='released_at')
        sort_order = request.args.get('sort_order', type=str, default='desc')
        page = request.args.get('page', type=int, default=1)
        per_page = request.args.get('per_page', type=int, default=20)

        query = Set.query

        # Apply filters
        if name:
            query = query.filter(Set.name.ilike(f'%{name}%'))
        if set_type:
            query = query.filter(Set.set_type == set_type)

        # Apply sorting
        if sort_order.lower() == 'asc':
            query = query.order_by(asc(getattr(Set, sort_by)))
        else:
            query = query.order_by(desc(getattr(Set, sort_by)))

        # Apply pagination
        paginated_sets = query.paginate(page=page, per_page=per_page, error_out=False)

        sets = [set.to_dict() for set in paginated_sets.items]

        return jsonify({
            'sets': sets,
            'total': paginated_sets.total,
            'pages': paginated_sets.pages,
            'current_page': paginated_sets.page
        }), 200
    except AttributeError:
        return jsonify({"error": f"Invalid sort_by field: {sort_by}"}), 400
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@set_routes.route('/sets/<string:set_code>', methods=['GET'])
def get_set(set_code):
    set = Set.query.filter_by(code=set_code).first_or_404()
    return jsonify(set.to_dict()), 200

@set_routes.route('/sets/<string:set_code>/cards', methods=['GET'])
def get_set_cards(set_code):
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    name = request.args.get('name', '', type=str)
    rarity = request.args.get('rarity', '', type=str)

    query = Card.query.filter_by(set_code=set_code)

    if name:
        query = query.filter(Card.name.ilike(f'%{name}%'))
    if rarity:
        query = query.filter(Card.rarity == rarity)

    cards = query.paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'cards': [card.to_dict() for card in cards.items],
        'total': cards.total,
        'pages': cards.pages,
        'current_page': cards.page
    }), 200
== End of backend/routes/set_routes.py ==

== Start of frontend/.eslintrc.js ==
module.exports = {
  root: true,
  env: {
    node: true,
  },
  extends: [
    'plugin:vue/vue3-essential',
    'eslint:recommended',
  ],
  parserOptions: {
    parser: '@babel/eslint-parser',
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
  },
};
== End of frontend/.eslintrc.js ==

== Start of frontend/index.html ==
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MTG Collection Kiosk</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
== End of frontend/index.html ==

== Start of frontend/vite.config.js ==
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
        secure: false,
      },
    },
  },
  build: {
    outDir: 'dist',
  },
})
== End of frontend/vite.config.js ==

== Start of frontend/src/App.vue ==
<template>
  <div id="app">
    <nav>
      <router-link to="/">Home</router-link> |
      <router-link to="/collection">Collection</router-link> |
      <router-link to="/kiosk">Kiosk</router-link> |
      <router-link to="/sets">Sets</router-link> |
      <router-link to="/import">Import</router-link>
    </nav>
    <router-view/>
  </div>
</template>

<script>
export default {
  name: 'App'
}
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  text-align: center;
  color: inherit; /* Inherit text color from body */
}
</style>
== End of frontend/src/App.vue ==

== Start of frontend/src/main.js ==
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import axios from 'axios'

import './assets/main.css'

const app = createApp(App)

app.use(router)

// Configure Axios
axios.defaults.baseURL = import.meta.env.VITE_API_URL || 'http://localhost:5000'

// Make Axios available globally
app.config.globalProperties.$axios = axios

app.mount('#app')
== End of frontend/src/main.js ==

== frontend/src/router.js not found ==

== Start of frontend/src/assets/main.css ==
/* Define CSS Variables for Dark Mode */
:root {
  --background-color: #121212;
  --text-color: #e0e0e0;
  --primary-color: #bb86fc;
  --secondary-color: #1f1f1f;
  --border-color: #333333;
  --input-background: #2c2c2c;
  --button-background: #333333;
  --button-hover-background: #444444;
  --link-color: #bb86fc;
  --error-color: #f44336;
  --success-color: #4caf50;
}

/* Apply Global Styles */
body {
  background-color: var(--background-color);
  color: var(--text-color);
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Link Styles */
a {
  color: var(--link-color);
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* Navigation Styles */
nav {
  background-color: var(--secondary-color);
  padding: 20px;
}

nav a {
  color: var(--text-color);
  margin: 0 10px;
  font-weight: bold;
}

nav a.router-link-exact-active {
  color: var(--primary-color);
}

/* Button Styles */
button {
  background-color: var(--button-background);
  color: var(--text-color);
  border: none;
  padding: 0.5rem 1rem;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}

button:hover {
  background-color: var(--button-hover-background);
}

button:disabled {
  background-color: #555555;
  cursor: not-allowed;
}

/* Form Elements */
input, select, textarea {
  background-color: var(--input-background);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  padding: 0.5rem;
  border-radius: 4px;
}

input::placeholder {
  color: #aaaaaa;
}

/* Card Styles */
.set-card, .card-item, .stat-card {
  background-color: var(--secondary-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 1rem;
  color: var(--text-color);
  transition: transform 0.3s ease;
}

.set-card:hover, .card-item:hover, .stat-card:hover {
  transform: scale(1.02);
}

/* Progress Bars */
.progress-container {
  width: 100%;
  background-color: var(--border-color);
  border-radius: 10px;
  margin: 10px 0;
  overflow: hidden;
}

.progress-bar {
  height: 10px;
  transition: width 0.5s ease-in-out;
}

/* Message Styles */
.message {
  margin-top: 1rem;
  padding: 1rem;
  border-radius: 4px;
}

.message.success {
  background-color: var(--success-color);
  color: #ffffff;
}

.message.error {
  background-color: var(--error-color);
  color: #ffffff;
}

/* Additional Global Styles */
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 15px;
}

/* Ensure all images and icons are compatible with dark mode */
img {
  max-width: 100%;
  height: auto;
}
== End of frontend/src/assets/main.css ==

== Start of frontend/src/components/SetListControls.vue ==
<template>
  <div class="controls">
    <div class="filter-section">
      <input
        v-model="localFilters.name"
        @input="emitFilters"
        placeholder="Search by name"
        class="input"
      />
      <select v-model="localFilters.set_type" @change="emitFilters" class="select">
        <option value="">All Types</option>
        <option v-for="type in setTypes" :key="type" :value="type">{{ capitalize(type) }}</option>
      </select>
    </div>
    <div class="sort-section">
      <label for="sortBy">Sort By:</label>
      <select v-model="localSorting.sortBy" @change="emitSorting" id="sortBy" class="select">
        <option value="released_at">Release Date</option>
        <option value="name">Name</option>
        <option value="collection_count">Collection Count</option>
      </select>
      <select v-model="localSorting.sortOrder" @change="emitSorting" class="select">
        <option value="asc">Ascending</option>
        <option value="desc">Descending</option>
      </select>
    </div>
    <div class="pagination-section">
      <label for="perPage">Per Page:</label>
      <select v-model="localPerPage" @change="emitPerPage" id="perPage" class="select">
        <option v-for="option in perPageOptions" :key="option" :value="option">{{ option }}</option>
      </select>
    </div>
  </div>
</template>

<script>
export default {
  name: 'SetListControls',
  props: {
    setTypes: {
      type: Array,
      required: true
    },
    totalPages: {
      type: Number,
      required: true
    }
  },
  data() {
    return {
      localFilters: {
        name: '',
        set_type: ''
      },
      localSorting: {
        sortBy: 'released_at',
        sortOrder: 'desc'
      },
      localPerPage: 20,
      perPageOptions: [10, 20, 50, 100]
    }
  },
  methods: {
    emitFilters() {
      this.$emit('update-filters', { ...this.localFilters })
    },
    emitSorting() {
      this.$emit('update-sorting', { ...this.localSorting })
    },
    emitPerPage() {
      this.$emit('update-per-page', this.localPerPage)
    },
    capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1)
    }
  }
}
</script>

<style scoped>
.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 1.5rem;
}

.filter-section,
.sort-section,
.pagination-section {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.input {
  padding: 0.5rem;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background-color: var(--input-background);
  color: var(--text-color);
}

.select {
  padding: 0.5rem;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background-color: var(--input-background);
  color: var(--text-color);
}

button {
  background-color: var(--primary-color);
  color: var(--text-color);
}

button:hover {
  background-color: var(--link-color);
}
</style>
== End of frontend/src/components/SetListControls.vue ==

== Start of frontend/src/router/index.js ==
import { createRouter, createWebHistory } from 'vue-router'
import Home from '../views/Home.vue'
import Collection from '../views/Collection.vue'
import CollectionSetCards from '../views/CollectionSetCards.vue'
import Kiosk from '../views/Kiosk.vue'
import Import from '../views/Import.vue'
import Sets from '../views/Sets.vue'
import SetDetails from '../views/SetDetails.vue'

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home
  },
  {
    path: '/collection',
    name: 'Collection',
    component: Collection
  },
  {
    path: '/collection/sets/:setCode',
    name: 'CollectionSetCards',
    component: CollectionSetCards,
    props: true
  },
  {
    path: '/kiosk',
    name: 'Kiosk',
    component: Kiosk
  },
  {
    path: '/import',
    name: 'Import',
    component: Import
  },
  {
    path: '/sets',
    name: 'Sets',
    component: Sets
  },
  {
    path: '/sets/:setCode',
    name: 'SetDetails',
    component: SetDetails,
    props: true
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
})

export default router
== End of frontend/src/router/index.js ==

== Start of frontend/src/views/Collection.vue ==
<template>
  <div class="collection">
    <h1>My Collection</h1>
    <div v-if="stats" class="collection-stats">
      <p>Total Cards: {{ stats.total_cards }}</p>
      <p>Unique Cards: {{ stats.unique_cards }}</p>
      <p>Total Value: ${{ stats.total_value.toFixed(2) }}</p>
    </div>
    <SetListControls
      :setTypes="setTypes"
      :totalPages="totalPages"
      @update-filters="updateFilters"
      @update-sorting="updateSorting"
      @update-per-page="updatePerPage"
    />
    <div v-if="loading" class="loading">Loading...</div>
    <div v-else-if="error" class="error">{{ error }}</div>
    <div v-else-if="sets && sets.length > 0" class="set-grid">
      <div v-for="set in sets" :key="set.code" class="set-card">
        <router-link :to="{ name: 'CollectionSetCards', params: { setCode: set.code } }">
          <div class="set-icon">
            <img :src="set.icon_svg_uri" :alt="set.name" />
            <div class="completion-circle" :style="{ '--percentage': set.collection_percentage + '%' }"></div>
          </div>
          <h3>{{ set.name }}</h3>
          <p>Code: {{ set.code }}</p>
          <p>Type: {{ set.set_type }}</p>
          <p>Released: {{ formatDate(set.released_at) }}</p>
          <p>Collection: {{ set.collection_count }} / {{ set.card_count }}</p>
          <p>Completion: {{ Math.round(set.collection_percentage) }}%</p>
        </router-link>
      </div>
    </div>
    <div v-else-if="!loading && sets.length === 0">
      <p>No sets found in your collection.</p>
    </div>
    <div class="pagination">
      <button @click="changePage(-1)" :disabled="currentPage === 1">Previous</button>
      <span>Page {{ currentPage }} of {{ totalPages }}</span>
      <button @click="changePage(1)" :disabled="currentPage === totalPages">Next</button>
    </div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import axios from 'axios'
import SetListControls from '../components/SetListControls.vue'

export default {
  name: 'Collection',
  components: {
    SetListControls
  },
  setup() {
    const sets = ref([])
    const stats = ref(null)
    const loading = ref(true)
    const error = ref(null)
    const filters = ref({})
    const sorting = ref({ sortBy: 'released_at', sortOrder: 'desc' })
    const currentPage = ref(1)
    const totalPages = ref(1)
    const perPage = ref(20)
    const setTypes = ref([
      'core', 'expansion', 'masters', 'draft_innovation', 'funny',
      'starter', 'box', 'promo', 'token', 'memorabilia'
    ])

    const fetchStats = async () => {
      try {
        const response = await axios.get('/api/collection/stats')
        stats.value = response.data
      } catch (err) {
        console.error('Error fetching collection stats:', err)
        error.value = 'Failed to load collection stats'
      }
    }

    const fetchSets = async () => {
      loading.value = true
      error.value = null
      try {
        const response = await axios.get('/api/collection/sets', {
          params: {
            ...filters.value,
            ...sorting.value,
            page: currentPage.value,
            per_page: perPage.value
          }
        })
        console.log('Response data:', response.data) // Added console.log
        sets.value = response.data.sets
        totalPages.value = response.data.pages
        currentPage.value = response.data.current_page
        console.log('Sets value:', sets.value) // Added console.log
      } catch (err) {
        console.error('Error fetching collection sets:', err)
        error.value = 'Failed to load collection sets'
      } finally {
        loading.value = false
      }
    }

    const updateFilters = (newFilters) => {
      filters.value = { ...filters.value, ...newFilters }
      currentPage.value = 1
      fetchSets()
    }

    const updateSorting = (newSorting) => {
      sorting.value = { ...newSorting }
      fetchSets()
    }

    const updatePerPage = (newPerPage) => {
      perPage.value = newPerPage
      currentPage.value = 1
      fetchSets()
    }

    const changePage = (delta) => {
      const newPage = currentPage.value + delta
      if (newPage >= 1 && newPage <= totalPages.value) {
        currentPage.value = newPage
        fetchSets()
      }
    }

    const formatDate = (dateString) => {
      return new Date(dateString).toLocaleDateString()
    }

    onMounted(() => {
      fetchStats()
      fetchSets()
    })

    return {
      sets,
      stats,
      loading,
      error,
      filters,
      sorting,
      currentPage,
      totalPages,
      perPage,
      setTypes,
      updateFilters,
      updateSorting,
      updatePerPage,
      changePage,
      formatDate
    }
  }
}
</script>

<style scoped>
.collection {
  padding: 1rem;
}

.collection-stats {
  display: flex;
  justify-content: space-around;
  margin-bottom: 1rem;
  background-color: #f0f0f0;
  padding: 1rem;
  border-radius: 8px;
}

.set-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 1rem;
}

.set-card {
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 1rem;
  text-align: center;
  background-color: #f9f9f9;
}

.set-icon {
  position: relative;
  width: 100px;
  height: 100px;
  margin: 0 auto 1rem;
}

.set-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.completion-circle {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: conic-gradient(
    #4CAF50 calc(var(--percentage) * 1%),
    #e0e0e0 calc(var(--percentage) * 1%)
  );
  opacity: 0.7;
}

.loading, .error {
  text-align: center;
  margin-top: 2rem;
  font-size: 1.2rem;
}

.pagination {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 2rem;
}

.pagination button {
  margin: 0 0.5rem;
  padding: 0.5rem 1rem;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.pagination button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}
</style>
== End of frontend/src/views/Collection.vue ==

== Start of frontend/src/views/CollectionSetCards.vue ==
<template>
  <div class="collection-set-cards">
    <h1>{{ setName }}</h1>
    <div v-if="loading" class="loading">Loading...</div>
    <div v-else-if="error" class="error">{{ error }}</div>
    <div v-else>
      <div class="filters">
        <input v-model="nameFilter" @input="applyFilters" placeholder="Filter by name" />
        <select v-model="rarityFilter" @change="applyFilters">
          <option value="">All Rarities</option>
          <option value="common">Common</option>
          <option value="uncommon">Uncommon</option>
          <option value="rare">Rare</option>
          <option value="mythic">Mythic</option>
        </select>
      </div>
      <div class="card-grid">
        <div v-for="card in cards" :key="card.id" class="card">
          <img :src="card.image_uris.small" :alt="card.name" />
          <h3>{{ card.name }}</h3>
          <p>Rarity: {{ card.rarity }}</p>
          <p>Regular: {{ card.quantity_regular }}</p>
          <p>Foil: {{ card.quantity_foil }}</p>
        </div>
      </div>
      <div class="pagination">
        <button @click="changePage(-1)" :disabled="currentPage === 1">Previous</button>
        <span>Page {{ currentPage }} of {{ totalPages }}</span>
        <button @click="changePage(1)" :disabled="currentPage === totalPages">Next</button>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, watch } from 'vue'
import axios from 'axios'
import { useRoute } from 'vue-router'

export default {
  name: 'CollectionSetCards',
  setup() {
    const route = useRoute()
    const setCode = ref(route.params.setCode)
    const setName = ref('')
    const cards = ref([])
    const loading = ref(true)
    const error = ref(null)
    const currentPage = ref(1)
    const totalPages = ref(1)
    const perPage = ref(20)
    const nameFilter = ref('')
    const rarityFilter = ref('')

    const fetchCards = async () => {
      loading.value = true
      error.value = null
      try {
        const response = await axios.get(`/api/collection/sets/${setCode.value}/cards`, {
          params: {
            page: currentPage.value,
            per_page: perPage.value,
            name: nameFilter.value,
            rarity: rarityFilter.value
          }
        })
        cards.value = response.data.cards
        totalPages.value = response.data.pages
        currentPage.value = response.data.current_page
        if (cards.value.length > 0) {
          setName.value = cards.value[0].set_name
        }
      } catch (err) {
        console.error('Error fetching set cards:', err)
        error.value = 'Failed to load set cards'
      } finally {
        loading.value = false
      }
    }

    const changePage = (delta) => {
      const newPage = currentPage.value + delta
      if (newPage >= 1 && newPage <= totalPages.value) {
        currentPage.value = newPage
        fetchCards()
      }
    }

    const applyFilters = () => {
      currentPage.value = 1
      fetchCards()
    }

    watch(() => route.params.setCode, (newSetCode) => {
      setCode.value = newSetCode
      currentPage.value = 1
      fetchCards()
    })

    onMounted(() => {
      fetchCards()
    })

    return {
      setName,
      cards,
      loading,
      error,
      currentPage,
      totalPages,
      nameFilter,
      rarityFilter,
      changePage,
      applyFilters
    }
  }
}
</script>

<style scoped>
.collection-set-cards {
  padding: 1rem;
}

.card-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 1rem;
}

.card {
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 1rem;
  text-align: center;
}

.card img {
  max-width: 100%;
  height: auto;
}

.filters {
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
}

.filters input,
.filters select {
  padding: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.loading,
.error {
  text-align: center;
  margin-top: 2rem;
  font-size: 1.2rem;
}

.pagination {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 2rem;
}

.pagination button {
  margin: 0 0.5rem;
  padding: 0.5rem 1rem;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.pagination button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}
</style>
== End of frontend/src/views/CollectionSetCards.vue ==

== Start of frontend/src/views/Home.vue ==
<template>
  <div class="home">
    <h1>MTG Collection Manager</h1>
    <div class="dashboard">
      <div class="stat-card">
        <h2>Total Cards</h2>
        <p>{{ stats.totalCards }}</p>
      </div>
      <div class="stat-card">
        <h2>Unique Cards</h2>
        <p>{{ stats.uniqueCards }}</p>
      </div>
      <div class="stat-card">
        <h2>Sets Collected</h2>
        <p>{{ stats.setsCollected }}</p>
      </div>
    </div>
    <button @click="refreshStats">Refresh Stats</button>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from 'vue'
import axios from 'axios'

export default {
  name: 'Home',
  setup() {
    const stats = ref({
      totalCards: 0,
      uniqueCards: 0,
      setsCollected: 0
    })
    let refreshInterval

    const fetchStats = async () => {
      try {
        const response = await axios.get('/api/stats')
        stats.value = response.data
      } catch (error) {
        console.error('Failed to fetch stats:', error)
      }
    }

    const refreshStats = () => {
      fetchStats()
    }

    onMounted(() => {
      fetchStats()
      refreshInterval = setInterval(fetchStats, 300000) // Refresh every 5 minutes
    })

    onUnmounted(() => {
      clearInterval(refreshInterval)
    })

    return {
      stats,
      refreshStats
    }
  }
}
</script>

<style scoped>
.home {
  padding: 1rem;
}

.dashboard {
  display: flex;
  justify-content: space-around;
  margin-top: 2rem;
}

.stat-card {
  background-color: var(--secondary-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 1rem;
  color: var(--text-color);
}

button {
  margin-top: 1rem;
  padding: 0.5rem 1rem;
  background-color: var(--primary-color);
  color: var(--text-color);
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background-color: var(--link-color);
}
</style>
== End of frontend/src/views/Home.vue ==

== Start of frontend/src/views/Import.vue ==
<template>
  <div class="import">
    <h1>Import Cards</h1>

    <div class="import-section">
      <h2>Import Single Card</h2>
      <form @submit.prevent="importSingleCard">
        <div>
          <label for="scryfallId">Scryfall ID:</label>
          <input v-model="singleCard.scryfallId" id="scryfallId" required>
        </div>
        <div>
          <label for="quantity">Quantity:</label>
          <input v-model.number="singleCard.quantity" id="quantity" type="number" min="1" required>
        </div>
        <div>
          <label for="foil">Foil:</label>
          <input v-model="singleCard.foil" id="foil" type="checkbox">
        </div>
        <div>
          <label for="destination">Destination:</label>
          <select v-model="singleCard.destination" id="destination" required>
            <option value="collection">Collection</option>
            <option value="kiosk">Kiosk</option>
          </select>
        </div>
        <button type="submit">Import Card</button>
      </form>
    </div>

    <div class="import-section">
      <h2>CSV Import Guidelines</h2>
      <p>Please ensure your CSV follows the format below:</p>
      <pre>
Name,Edition,Edition code,Collector's number,Price,Foil,Currency,Scryfall ID,Quantity
"Saw","Duskmourn: House of Horror","DSK","254","$0.21","Foil","USD","603c3ef4-4ef1-4db8-9ed2-e2b0926269d5","2"
      </pre>
      <a href="/static/csv_template.csv" download="csv_template.csv">Download CSV Template</a>
    </div>

    <div class="import-section">
      <h2>Import from CSV</h2>
      <form @submit.prevent="importFromCSV">
        <div>
          <label for="csvFile">CSV File:</label>
          <input type="file" id="csvFile" @change="handleFileUpload" accept=".csv" required>
        </div>
        <button type="submit">Import CSV</button>
      </form>
    </div>

    <div v-if="message" :class="['message', messageType]">
      {{ message }}
    </div>
  </div>
</template>

<script>
import { ref } from 'vue'
import axios from 'axios'

export default {
  name: 'Import',
  setup() {
    const singleCard = ref({
      scryfallId: '',
      quantity: 1,
      foil: false,
      destination: 'collection'
    })

    const csvImport = ref({
      file: null
    })

    const message = ref('')
    const messageType = ref('')

    const importSingleCard = async () => {
      try {
        const response = await axios.post(`/api/collection`, {
          scryfall_id: singleCard.value.scryfallId,
          quantity: singleCard.value.quantity,
          foil: singleCard.value.foil ? 1 : 0
        })
        message.value = `Card imported successfully: ${response.data.message}`
        messageType.value = 'success'
        // Reset form
        singleCard.value = { scryfallId: '', quantity: 1, foil: false, destination: 'collection' }
      } catch (error) {
        message.value = `Error importing card: ${error.response?.data?.error || error.message}`
        messageType.value = 'error'
      }
    }

    const handleFileUpload = (event) => {
      csvImport.value.file = event.target.files[0]
    }

    const importFromCSV = async () => {
      if (!csvImport.value.file) {
        message.value = 'Please select a CSV file'
        messageType.value = 'error'
        return
      }

      const formData = new FormData()
      formData.append('file', csvImport.value.file)

      try {
        const response = await axios.post('/api/collection/import_csv', formData, {
          headers: {
            'Content-Type': 'multipart/form-data'
          }
        })
        message.value = `CSV imported successfully: ${response.data.message}`
        messageType.value = 'success'
        // Reset form
        csvImport.value = { file: null }
      } catch (error) {
        message.value = `Error importing CSV: ${error.response?.data?.error || error.message}`
        messageType.value = 'error'
      }
    }

    return {
      singleCard,
      csvImport,
      message,
      messageType,
      importSingleCard,
      handleFileUpload,
      importFromCSV
    }
  }
}
</script>

<style scoped>
.import-section {
  margin-bottom: 2rem;
}

form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  max-width: 400px;
  margin: 0 auto;
}

label {
  font-weight: bold;
}

input[type="text"],
input[type="number"],
select {
  width: 100%;
  padding: 0.5rem;
}

button {
  padding: 0.5rem 1rem;
  background-color: #4CAF50;
  color: white;
  border: none;
  cursor: pointer;
}

button:hover {
  background-color: #45a049;
}

.message {
  margin-top: 1rem;
  padding: 1rem;
  border-radius: 4px;
}

.success {
  background-color: #dff0d8;
  color: #3c763d;
}

.error {
  background-color: #f2dede;
  color: #a94442;
}

pre {
  background-color: #f4f4f4;
  border: 1px solid #ddd;
  border-left: 3px solid #4CAF50;
  color: #666;
  page-break-inside: avoid;
  font-family: monospace;
  font-size: 15px;
  line-height: 1.6;
  margin-bottom: 1.6em;
  max-width: 100%;
  overflow: auto;
  padding: 1em 1.5em;
  display: block;
  word-wrap: break-word;
}
</style>
== End of frontend/src/views/Import.vue ==

== Start of frontend/src/views/Kiosk.vue ==
<template>
  <div class="kiosk">
    <h1>Kiosk Inventory</h1>
    <div class="filters">
      <input v-model="filters.name" placeholder="Search by name" @input="fetchCards">
      <select v-model="filters.set" @change="fetchCards">
        <option value="">All Sets</option>
        <option v-for="set in sets" :key="set.code" :value="set.code">{{ set.name }}</option>
      </select>
      <select v-model="filters.rarity" @change="fetchCards">
        <option value="">All Rarities</option>
        <option value="common">Common</option>
        <option value="uncommon">Uncommon</option>
        <option value="rare">Rare</option>
        <option value="mythic">Mythic</option>
      </select>
    </div>
    <div class="card-list">
      <div v-for="card in cards" :key="card.id" class="card-item">
        <img :src="card.image_uris.small" :alt="card.name">
        <div class="card-details">
          <h3>{{ card.name }}</h3>
          <p>Set: {{ card.set_name }}</p>
          <p>Rarity: {{ card.rarity }}</p>
          <p>Regular: {{ card.quantity.quantity_regular }}</p>
          <p>Foil: {{ card.quantity.quantity_foil }}</p>
          <button @click="openEditModal(card)">Edit</button>
        </div>
      </div>
    </div>
    <div class="pagination">
      <button @click="changePage(-1)" :disabled="currentPage === 1">Previous</button>
      <span>Page {{ currentPage }} of {{ totalPages }}</span>
      <button @click="changePage(1)" :disabled="currentPage === totalPages">Next</button>
    </div>
    <!-- Edit Modal (implement later) -->
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import axios from 'axios'

export default {
  name: 'Kiosk',
  setup() {
    const cards = ref([])
    const sets = ref([])
    const filters = ref({ name: '', set: '', rarity: '' })
    const currentPage = ref(1)
    const totalPages = ref(1)

    const fetchCards = async () => {
      try {
        const response = await axios.get('/api/kiosk', {
          params: {
            ...filters.value,
            page: currentPage.value
          }
        })
        cards.value = response.data.kiosk
        totalPages.value = response.data.pages
      } catch (error) {
        console.error('Error fetching kiosk cards:', error)
      }
    }

    const fetchSets = async () => {
      try {
        const response = await axios.get('/api/sets')
        sets.value = response.data.sets
      } catch (error) {
        console.error('Error fetching sets:', error)
      }
    }

    const changePage = (delta) => {
      currentPage.value += delta
      fetchCards()
    }

    const openEditModal = (card) => {
      // Implement edit modal logic
      console.log('Edit kiosk card:', card)
    }

    onMounted(() => {
      fetchCards()
      fetchSets()
    })

    return {
      cards,
      sets,
      filters,
      currentPage,
      totalPages,
      fetchCards,
      changePage,
      openEditModal
    }
  }
}
</script>

<style scoped>
.filters {
  margin-bottom: 1rem;
}

.card-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 1rem;
}

.card-item {
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 0.5rem;
}

.card-item img {
  width: 100%;
  height: auto;
}

.pagination {
  margin-top: 1rem;
}
</style>
== End of frontend/src/views/Kiosk.vue ==

== Start of frontend/src/views/SetDetails.vue ==
<template>
  <div class="set-details">
    <div v-if="set" class="set-info">
      <img :src="set.icon_svg_uri" :alt="set.name" class="set-icon">
      <h1>{{ set.name }}</h1>
      <p>Code: {{ set.code }}</p>
      <p>Released: {{ new Date(set.released_at).toLocaleDateString() }}</p>
      <p>Card Count: {{ set.card_count }}</p>
      <p>Set Type: {{ set.set_type }}</p>
    </div>

    <h2>Cards in this Set</h2>
    <div class="filters">
      <input v-model="filters.name" placeholder="Search by card name" @input="fetchCards">
      <select v-model="filters.rarity" @change="fetchCards">
        <option value="">All Rarities</option>
        <option value="common">Common</option>
        <option value="uncommon">Uncommon</option>
        <option value="rare">Rare</option>
        <option value="mythic">Mythic</option>
      </select>
    </div>

    <div class="card-list">
      <div v-for="card in cards" :key="card.id" class="card-item">
        <img :src="card.image_uris.small" :alt="card.name">
        <div class="card-details">
          <h3>{{ card.name }}</h3>
          <p>Rarity: {{ card.rarity }}</p>
          <p>Collector Number: {{ card.collector_number }}</p>
          <p v-if="card.collection">In Collection: {{ card.collection.quantity_regular + card.collection.quantity_foil }}</p>
          <p v-if="card.kiosk">In Kiosk: {{ card.kiosk.quantity_regular + card.kiosk.quantity_foil }}</p>
        </div>
      </div>
    </div>

    <div class="pagination">
      <button @click="changePage(-1)" :disabled="currentPage === 1">Previous</button>
      <span>Page {{ currentPage }} of {{ totalPages }}</span>
      <button @click="changePage(1)" :disabled="currentPage === totalPages">Next</button>
    </div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import axios from 'axios'

export default {
  name: 'SetDetails',
  props: {
    setCode: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const set = ref(null)
    const cards = ref([])
    const filters = ref({ name: '', rarity: '' })
    const currentPage = ref(1)
    const totalPages = ref(1)

    const fetchSet = async () => {
      try {
        const response = await axios.get(`/api/sets/${props.setCode}`)
        set.value = response.data
      } catch (error) {
        console.error('Error fetching set details:', error)
      }
    }

    const fetchCards = async () => {
      try {
        const response = await axios.get(`/api/sets/${props.setCode}/cards`, {
          params: {
            ...filters.value,
            page: currentPage.value
          }
        })
        cards.value = response.data.cards
        totalPages.value = response.data.pages
      } catch (error) {
        console.error('Error fetching set cards:', error)
      }
    }

    const changePage = (delta) => {
      currentPage.value += delta
      fetchCards()
    }

    onMounted(() => {
      fetchSet()
      fetchCards()
    })

    return {
      set,
      cards,
      filters,
      currentPage,
      totalPages,
      fetchCards,
      changePage
    }
  }
}
</script>

<style scoped>
.set-info {
  text-align: center;
  margin-bottom: 2rem;
}

.set-icon {
  width: 100px;
  height: 100px;
}

.filters {
  margin-bottom: 1rem;
}

.card-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 1rem;
}

.card-item {
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 0.5rem;
}

.card-item img {
  width: 100%;
  height: auto;
}

.pagination {
  margin-top: 1rem;
}
</style>
== End of frontend/src/views/SetDetails.vue ==

== Start of frontend/src/views/Sets.vue ==
<template>
  <div class="sets">
    <h1>Magic: The Gathering Sets</h1>
    <div v-if="loading">Loading sets...</div>
    <div v-else-if="error">Error: {{ error }}</div>
    <div v-else-if="sets.length === 0">No sets found.</div>
    <div v-else>
      <p>Total sets: {{ sets.length }}</p>
      <div class="set-grid">
        <div v-for="set in sets" :key="set.code" class="set-card">
          <router-link :to="{ name: 'SetDetails', params: { setCode: set.code } }">
            <img :src="set.icon_svg_uri" :alt="set.name" class="set-icon" />
            <h2>{{ set.name }}</h2>
            <p>Released: {{ formatDate(set.released_at) }}</p>
            <div class="progress-container">
              <div
                class="progress-bar"
                :style="{ width: `${set.collection_percentage}%` }"
                :class="getProgressBarClass(set.collection_percentage)"
              ></div>
            </div>
            <p class="collection-status">{{ formatCollectionProgress(set) }}</p>
          </router-link>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import axios from 'axios'

export default {
  name: 'Sets',
  setup() {
    const sets = ref([])
    const filters = ref({ name: '', set_type: '' })
    const currentPage = ref(1)
    const totalPages = ref(1)
    const loading = ref(true)
    const error = ref(null)

    const fetchSets = async () => {
      loading.value = true
      error.value = null
      try {
        const response = await axios.get('/api/sets', {
          params: {
            ...filters.value,
            page: currentPage.value
          }
        })
        sets.value = response.data.sets
        totalPages.value = response.data.pages
      } catch (err) {
        console.error('Error fetching sets:', err)
        error.value = 'Failed to load sets'
      } finally {
        loading.value = false
      }
    }

    const changePage = (delta) => {
      currentPage.value += delta
      fetchSets()
    }

    const formatDate = (dateString) => {
      return dateString ? new Date(dateString).toLocaleDateString() : 'N/A'
    }

    const formatCollectionProgress = (set) => {
      if (set.collection_count === 0) {
        return 'Not Started (0%)'
      } else if (set.collection_count === set.card_count) {
        return 'Complete (100%)'
      } else {
        return `${set.collection_count}/${set.card_count} (${set.collection_percentage.toFixed(2)}%)`
      }
    }

    const getProgressBarClass = (percentage) => {
      if (percentage === 0) return 'not-started'
      if (percentage < 25) return 'just-started'
      if (percentage < 50) return 'in-progress'
      if (percentage < 75) return 'well-progressed'
      if (percentage < 100) return 'almost-complete'
      return 'complete'
    }

    onMounted(fetchSets)

    return {
      sets,
      filters,
      currentPage,
      totalPages,
      loading,
      error,
      fetchSets,
      changePage,
      formatDate,
      formatCollectionProgress,
      getProgressBarClass
    }
  }
}
</script>

<style scoped>
.sets {
  padding: 20px;
}

.sets h1 {
  font-size: 2em;
  color: #ffffff;
  margin-bottom: 20px;
  text-align: center;
}

.set-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 20px;
  margin-bottom: 20px;
}

.set-card {
  background-color: #2c3e50;
  border-radius: 8px;
  padding: 15px;
  text-align: center;
  transition: transform 0.3s ease;
}

.set-card:hover {
  transform: scale(1.05);
}

.set-icon {
  width: 50px;
  height: 50px;
  margin-bottom: 10px;
}

.set-card h2 {
  font-size: 1.2em;
  color: #ffffff;
  margin-bottom: 5px;
}

.set-card p {
  font-size: 0.9em;
  color: #cccccc;
  margin: 5px 0;
}

.progress-container {
  width: 100%;
  background-color: #34495e;
  border-radius: 10px;
  margin: 10px 0;
  overflow: hidden;
}

.progress-bar {
  height: 10px;
  transition: width 0.5s ease-in-out;
}

.progress-bar.not-started {
  background-color: #95a5a6;
}
.progress-bar.just-started {
  background-color: #e74c3c;
}
.progress-bar.in-progress {
  background-color: #e67e22;
}
.progress-bar.well-progressed {
  background-color: #f1c40f;
}
.progress-bar.almost-complete {
  background-color: #2ecc71;
}
.progress-bar.complete {
  background-color: #3498db;
}

.collection-status {
  font-weight: bold;
  color: #ffffff;
}
</style>
== End of frontend/src/views/Sets.vue ==

