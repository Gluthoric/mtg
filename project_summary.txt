== Start of backend/config.py ==
import os
from dotenv import load_dotenv

# Load environment variables from the .env file
load_dotenv()

class Config:
    # The base configuration class that other environments will inherit from
    SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URI')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SECRET_KEY = os.getenv('SECRET_KEY')

class DevelopmentConfig(Config):
    # Development-specific settings
    DEBUG = True

class TestingConfig(Config):
    # Testing-specific settings
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.getenv('TEST_DATABASE_URI')

class ProductionConfig(Config):
    # Production-specific settings
    DEBUG = False

# Map configuration names to their corresponding config classes
config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
== End of backend/config.py ==

== Start of backend/database.py ==
# Database initialization and models

from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

# Import models here to avoid circular imports
from models.card import Card
from models.set import Set
from models.collection import Collection
from models.kiosk import Kiosk
== End of backend/database.py ==

== Start of backend/main.py ==
from flask import Flask
from flask_cors import CORS
from config import Config
from database import db
from routes import register_routes
from routes.set_routes import set_routes
from routes.kiosk_routes import kiosk_routes
import redis
import orjson

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)

    # Initialize extensions
    db.init_app(app)
    CORS(app)

    # Register routes
    register_routes(app)
    app.register_blueprint(set_routes, url_prefix='/api')
    app.register_blueprint(kiosk_routes, url_prefix='/api')

    # Add Redis client to app context
    app.redis_client = redis_client

    # Use orjson for JSON serialization
    app.json_encoder = orjson.dumps
    app.json_decoder = orjson.loads

    return app

if __name__ == '__main__':
    app = create_app()
    app.run(debug=True)
== End of backend/main.py ==

== Start of backend/models/card.py ==
from database import db
from sqlalchemy.dialects.postgresql import JSONB

class Card(db.Model):
    __tablename__ = 'cards'

    id = db.Column(db.Text, primary_key=True)
    oracle_id = db.Column(db.Text, index=True)
    multiverse_ids = db.Column(JSONB)
    mtgo_id = db.Column(db.BigInteger)
    arena_id = db.Column(db.BigInteger)
    tcgplayer_id = db.Column(db.BigInteger)
    name = db.Column(db.Text, nullable=False, index=True)
    lang = db.Column(db.Text)
    released_at = db.Column(db.Text)
    uri = db.Column(db.Text)
    scryfall_uri = db.Column(db.Text)
    layout = db.Column(db.Text)
    highres_image = db.Column(db.Boolean)
    image_status = db.Column(db.Text)
    image_uris = db.Column(JSONB)  # Now correctly mapped to JSONB
    mana_cost = db.Column(db.Text)
    cmc = db.Column(db.Float)
    type_line = db.Column(db.Text, index=True)
    oracle_text = db.Column(db.Text)
    colors = db.Column(JSONB)
    color_identity = db.Column(JSONB)
    keywords = db.Column(JSONB)
    produced_mana = db.Column(JSONB)
    legalities = db.Column(JSONB)
    games = db.Column(JSONB)
    reserved = db.Column(db.Boolean)
    foil = db.Column(db.Boolean)
    nonfoil = db.Column(db.Boolean)
    finishes = db.Column(JSONB)
    oversized = db.Column(db.Boolean)
    promo = db.Column(db.Boolean)
    full_art = db.Column(db.Boolean)
    textless = db.Column(db.Boolean)
    booster = db.Column(db.Boolean)
    story_spotlight = db.Column(db.Boolean)
    reprint = db.Column(db.Boolean)
    variation = db.Column(db.Boolean)
    set_code = db.Column(db.Text, db.ForeignKey('sets.code'), index=True)
    set_name = db.Column(db.Text)
    collector_number = db.Column(db.Text, nullable=False, default='0')
    digital = db.Column(db.Boolean)
    rarity = db.Column(db.Text, index=True)
    card_back_id = db.Column(db.Text)
    artist = db.Column(db.Text)
    artist_ids = db.Column(JSONB)
    illustration_id = db.Column(db.Text)
    border_color = db.Column(db.Text)
    frame = db.Column(db.Text)
    prices = db.Column(JSONB)
    related_uris = db.Column(JSONB)
    purchase_uris = db.Column(JSONB)

    # Relationships
    set = db.relationship('Set', back_populates='cards')
    collection = db.relationship('Collection', back_populates='card', uselist=False, cascade='all, delete-orphan')
    kiosk = db.relationship('Kiosk', back_populates='card', uselist=False, cascade='all, delete-orphan')

    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'set_name': self.set_name,
            'set_code': self.set_code,
            'collector_number': self.collector_number if self.collector_number else 'N/A',
            'type_line': self.type_line,
            'rarity': self.rarity,
            'mana_cost': self.mana_cost,
            'cmc': self.cmc,
            'oracle_text': self.oracle_text,
            'colors': self.colors,
            'image_uris': self.image_uris if self.image_uris else {},
            'prices': self.prices,
            'collection': self.collection.to_dict() if self.collection else None,
            'kiosk': self.kiosk.to_dict() if self.kiosk else None
        }
== End of backend/models/card.py ==

== Start of backend/models/collection.py ==
from database import db

class Collection(db.Model):
    __tablename__ = 'collections'

    id = db.Column(db.BigInteger, primary_key=True, autoincrement=True)
    card_id = db.Column(db.Text, db.ForeignKey('cards.id'), nullable=False)
    quantity_regular = db.Column(db.BigInteger, default=0)
    quantity_foil = db.Column(db.BigInteger, default=0)

    # Relationship
    card = db.relationship('Card', back_populates='collection')

    def to_dict(self):
        return {
            'id': self.id,
            'card_id': self.card_id,
            'quantity_regular': self.quantity_regular,
            'quantity_foil': self.quantity_foil
        }
== End of backend/models/collection.py ==

== Start of backend/models/kiosk.py ==
from database import db

class Kiosk(db.Model):
    __tablename__ = 'kiosk'

    id = db.Column(db.BigInteger, primary_key=True, autoincrement=True)
    card_id = db.Column(db.Text, db.ForeignKey('cards.id'), nullable=False)
    quantity_regular = db.Column(db.BigInteger, default=0)
    quantity_foil = db.Column(db.BigInteger, default=0)

    # Relationship
    card = db.relationship('Card', back_populates='kiosk')

    def to_dict(self):
        return {
            'id': self.id,
            'card_id': self.card_id,
            'quantity_regular': self.quantity_regular,
            'quantity_foil': self.quantity_foil
        }
== End of backend/models/kiosk.py ==

== Start of backend/models/set.py ==
from database import db
from models.collection import Collection
from models.card import Card

class Set(db.Model):
    __tablename__ = 'sets'

    id = db.Column(db.Text, primary_key=True)
    code = db.Column(db.Text, unique=True, nullable=False, index=True)
    name = db.Column(db.Text, nullable=False)
    released_at = db.Column(db.Text)
    set_type = db.Column(db.Text)
    card_count = db.Column(db.BigInteger)
    digital = db.Column(db.Boolean)
    foil_only = db.Column(db.Boolean)
    icon_svg_uri = db.Column(db.Text)

    # Relationships
    cards = db.relationship('Card', back_populates='set')

    def to_dict(self):
        collection_count = self.get_collection_count()
        collection_percentage = (collection_count / self.card_count) * 100 if self.card_count else 0
        return {
            'id': self.id,
            'code': self.code,
            'name': self.name,
            'released_at': self.released_at,
            'set_type': self.set_type,
            'card_count': self.card_count,
            'digital': self.digital,
            'foil_only': self.foil_only,
            'icon_svg_uri': self.icon_svg_uri,
            'collection_count': collection_count,
            'collection_percentage': collection_percentage
        }

    def get_collection_count(self):
        # Count the number of unique cards in the collection for this set
        return db.session.query(db.func.count(Collection.card_id)) \
            .join(Card, Card.id == Collection.card_id) \
            .filter(Card.set_code == self.code) \
            .scalar() or 0
== End of backend/models/set.py ==

== Start of backend/routes/__init__.py ==
from flask import Blueprint
from .card_routes import card_routes
from .set_routes import set_routes
from .collection_routes import collection_routes
from .kiosk_routes import kiosk_routes

def register_routes(app):
    api = Blueprint('api', __name__, url_prefix='/api')

    api.register_blueprint(card_routes)
    api.register_blueprint(set_routes)
    api.register_blueprint(collection_routes)
    api.register_blueprint(kiosk_routes)

    app.register_blueprint(api)

    @app.route('/')
    def index():
        return "Welcome to the MTG Collection Kiosk API"
== End of backend/routes/__init__.py ==

== Start of backend/routes/card_routes.py ==
from flask import Blueprint, jsonify, request
from models.card import Card
from database import db
from sqlalchemy import or_

card_routes = Blueprint('card_routes', __name__)

@card_routes.route('/cards', methods=['GET'])
def get_cards():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    name = request.args.get('name', '')
    set_code = request.args.get('set_code', '')
    rarity = request.args.get('rarity', '')
    colors = request.args.get('colors', '').split(',') if request.args.get('colors') else []

    query = Card.query

    if name:
        query = query.filter(Card.name.ilike(f'%{name}%'))
    if set_code:
        query = query.filter(Card.set_code == set_code)
    if rarity:
        query = query.filter(Card.rarity == rarity)
    if colors:
        query = query.filter(or_(*[Card.colors.contains([color]) for color in colors]))

    cards = query.paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'cards': [card.to_dict() for card in cards.items],
        'total': cards.total,
        'pages': cards.pages,
        'current_page': page
    }), 200

@card_routes.route('/cards/<string:card_id>', methods=['GET'])
def get_card(card_id):
    card = Card.query.get_or_404(card_id)
    return jsonify(card.to_dict()), 200

@card_routes.route('/cards/search', methods=['GET'])
def search_cards():
    query = request.args.get('q', '')
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)

    cards = Card.query.filter(
        or_(
            Card.name.ilike(f'%{query}%'),
            Card.type_line.ilike(f'%{query}%'),
            Card.oracle_text.ilike(f'%{query}%')
        )
    ).paginate(page=page, per_page=per_page, error_out=False)

    return jsonify({
        'cards': [card.to_dict() for card in cards.items],
        'total': cards.total,
        'pages': cards.pages,
        'current_page': page
    }), 200
== End of backend/routes/card_routes.py ==

== Start of backend/routes/collection_routes.py ==
import pandas as pd
from flask import Blueprint, jsonify, request, current_app
from sqlalchemy.orm import joinedload
from sqlalchemy.sql import func, asc, desc, text
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from models.collection import Collection
from models.card import Card
from models.kiosk import Kiosk
from models.set import Set
from database import db
import time
import logging
import orjson

collection_routes = Blueprint('collection_routes', __name__)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def serialize_collection(collection_items):
    return [{
        **item.card.to_dict(),
        'quantity_regular': item.quantity_regular,
        'quantity_foil': item.quantity_foil
    } for item in collection_items]

@collection_routes.route('/collection', methods=['GET'])
def get_collection():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    set_code = request.args.get('set_code', '', type=str)

    cache_key = f"collection:page:{page}:per_page:{per_page}:set_code:{set_code}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    query = Collection.query.join(Card).join(Set)

    if set_code:
        query = query.filter(Set.code == set_code)

    collection = query.paginate(page=page, per_page=per_page, error_out=False)

    result = {
        'collection': serialize_collection(collection.items),
        'total': collection.total,
        'pages': collection.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@collection_routes.route('/collection/sets', methods=['GET'])
def get_collection_sets():
    try:
        name = request.args.get('name', type=str)
        set_type = request.args.get('set_type', type=str)
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        sort_by = request.args.get('sort_by', 'released_at', type=str)
        sort_order = request.args.get('sort_order', 'desc', type=str)

        cache_key = f"collection_sets:name:{name}:set_type:{set_type}:page:{page}:per_page:{per_page}:sort_by:{sort_by}:sort_order:{sort_order}"
        cached_data = current_app.redis_client.get(cache_key)

        if cached_data:
            return current_app.response_class(
                response=cached_data,
                status=200,
                mimetype='application/json'
            )

        logger.info(f"Received parameters: name={name}, set_type={set_type}, sort_by={sort_by}, sort_order={sort_order}, page={page}, per_page={per_page}")

        query = db.session.query(
            Set.id,
            Set.code,
            Set.name,
            Set.released_at,
            Set.set_type,
            Set.card_count,
            Set.digital,
            Set.foil_only,
            Set.icon_svg_uri,
            func.count(Collection.card_id).label('collection_count')
        ).outerjoin(Card, Card.set_code == Set.code
        ).outerjoin(Collection, Collection.card_id == Card.id
        ).group_by(
            Set.id,
            Set.code,
            Set.name,
            Set.released_at,
            Set.set_type,
            Set.card_count,
            Set.digital,
            Set.foil_only,
            Set.icon_svg_uri
        )

        if name:
            query = query.filter(Set.name.ilike(f'%{name}%'))
            logger.info(f"Applied filter: Set.name ilike '%{name}%'")
        if set_type:
            query = query.filter(Set.set_type == set_type)
            logger.info(f"Applied filter: Set.set_type == '{set_type}'")

        valid_sort_fields = {'released_at', 'name', 'collection_count', 'card_count'}
        if sort_by not in valid_sort_fields:
            error_message = f"Invalid sort_by field: {sort_by}"
            logger.error(error_message)
            return jsonify({"error": error_message}), 400

        if sort_by == 'collection_count':
            sort_column = func.count(Collection.card_id)
        else:
            sort_column = getattr(Set, sort_by)

        if sort_order.lower() == 'asc':
            query = query.order_by(asc(sort_column))
            logger.info(f"Sorting by {sort_by} in ascending order")
        else:
            query = query.order_by(desc(sort_column))
            logger.info(f"Sorting by {sort_by} in descending order")

        paginated_sets = query.paginate(page=page, per_page=per_page, error_out=False)
        logger.info(f"Paginated sets: page={paginated_sets.page}, pages={paginated_sets.pages}, total={paginated_sets.total}")

        sets_list = []
        for row in paginated_sets.items:
            set_data = {
                'id': row.id,
                'code': row.code,
                'name': row.name,
                'released_at': row.released_at,
                'set_type': row.set_type,
                'card_count': row.card_count,
                'digital': row.digital,
                'foil_only': row.foil_only,
                'icon_svg_uri': row.icon_svg_uri
            }
            collection_count = row.collection_count
            collection_percentage = (collection_count / row.card_count) * 100 if row.card_count else 0
            sets_list.append({
                **set_data,
                'collection_count': collection_count,
                'collection_percentage': collection_percentage
            })

        response = {
            'sets': sets_list,
            'total': paginated_sets.total,
            'pages': paginated_sets.pages,
            'current_page': paginated_sets.page
        }

        serialized_data = orjson.dumps(response)
        current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

        logger.info(f"Returning response with {len(sets_list)} sets")
        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        error_message = f"An unexpected error occurred: {str(e)}"
        logger.exception(error_message)
        return jsonify({"error": error_message}), 500

@collection_routes.route('/collection/<string:card_id>', methods=['POST', 'PUT'])
def update_collection(card_id):
    data = request.json
    quantity_regular = data.get('quantity_regular', 0)
    quantity_foil = data.get('quantity_foil', 0)

    collection_item = Collection.query.filter_by(card_id=card_id).first()

    if collection_item:
        collection_item.quantity_regular = quantity_regular
        collection_item.quantity_foil = quantity_foil
    else:
        collection_item = Collection(card_id=card_id, quantity_regular=quantity_regular, quantity_foil=quantity_foil)
        db.session.add(collection_item)

    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("collection:*")
    current_app.redis_client.delete("collection_sets:*")
    current_app.redis_client.delete("collection_stats")

    card = Card.query.filter_by(id=card_id).first()
    if not card:
        return jsonify({"error": "Card not found."}), 404

    card_data = card.to_dict()
    card_data.update({
        'quantity_regular': collection_item.quantity_regular,
        'quantity_foil': collection_item.quantity_foil
    })

    return current_app.response_class(
        response=orjson.dumps(card_data),
        status=200,
        mimetype='application/json'
    )

@collection_routes.route('/collection/<string:card_id>', methods=['DELETE'])
def remove_from_collection(card_id):
    collection_item = Collection.query.filter_by(card_id=card_id).first_or_404()
    db.session.delete(collection_item)
    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("collection:*")
    current_app.redis_client.delete("collection_sets:*")
    current_app.redis_client.delete("collection_stats")

    return '', 204

@collection_routes.route('/collection/stats', methods=['GET'])
def get_collection_stats():
    try:
        cache_key = "collection_stats"
        cached_data = current_app.redis_client.get(cache_key)

        if cached_data:
            return current_app.response_class(
                response=cached_data,
                status=200,
                mimetype='application/json'
            )

        total_cards = db.session.query(func.sum(Collection.quantity_regular + Collection.quantity_foil)).scalar() or 0
        unique_cards = Collection.query.count()

        total_value_query = text("""
            SELECT SUM(
                (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * collections.quantity_regular) +
                (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * collections.quantity_foil)
            )
            FROM collections
            JOIN cards ON cards.id = collections.card_id
        """)
        total_value = db.session.execute(total_value_query).scalar() or 0

        result = {
            'total_cards': int(total_cards),
            'unique_cards': unique_cards,
            'total_value': round(total_value, 2)
        }

        serialized_data = orjson.dumps(result)
        current_app.redis_client.setex(cache_key, 3600, serialized_data)  # Cache for 1 hour

        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@collection_routes.route('/collection/sets/<string:set_code>/cards', methods=['GET'])
def get_collection_set_cards(set_code):
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 300, type=int)
    name = request.args.get('name', '', type=str)
    rarity = request.args.get('rarity', '', type=str)

    cache_key = f"collection_set_cards:{set_code}:page:{page}:per_page:{per_page}:name:{name}:rarity:{rarity}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    query = Collection.query.join(Card).join(Set).filter(Set.code == set_code)

    if name:
        query = query.filter(Card.name.ilike(f'%{name}%'))
    if rarity:
        query = query.filter(Card.rarity == rarity)

    collection = query.paginate(page=page, per_page=per_page, error_out=False)

    result = {
        'cards': serialize_collection(collection.items),
        'total': collection.total,
        'pages': collection.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@collection_routes.route('/collection/import_csv', methods=['POST'])
def import_csv():
    if 'file' not in request.files:
        return jsonify({"error": "No file part in the request"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No file selected"}), 400

    if not file.filename.endswith('.csv'):
        return jsonify({"error": "Only CSV files are allowed"}), 400

    try:
        df = pd.read_csv(file)
    except Exception as e:
        logger.error(f"Failed to parse CSV: {str(e)}")
        return jsonify({"error": f"Failed to parse CSV: {str(e)}"}), 400

    required_columns = {
        'Name', 'Edition', 'Edition code', "Collector's number",
        'Price', 'Foil', 'Currency', 'Scryfall ID', 'Quantity'
    }
    if not required_columns.issubset(set(df.columns)):
        missing = required_columns - set(df.columns)
        return jsonify({"error": f"CSV is missing columns: {', '.join(missing)}"}), 400

    df['Foil'] = df['Foil'].fillna(False).replace('', False)

    try:
        with db.session.begin_nested():
            for index, row in df.iterrows():
                try:
                    process_csv_row(row, index)
                except ValueError as e:
                    logger.error(f"Error processing row {index + 2}: {str(e)}")
                    continue
                except IntegrityError as e:
                    logger.error(f"IntegrityError at row {index + 2}: {str(e)}")
                    db.session.rollback()
                    return jsonify({"error": f"Database integrity error at row {index + 2}: {str(e)}"}), 500

                if index % 100 == 0:
                    db.session.flush()

        db.session.commit()
        logger.info("CSV imported successfully")

        # Invalidate related caches
        current_app.redis_client.delete("collection:*")
        current_app.redis_client.delete("collection_sets:*")
        current_app.redis_client.delete("collection_stats")

        return jsonify({"message": "CSV imported successfully"}), 200

    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error(f"Database error during CSV import: {str(e)}")
        return jsonify({"error": f"Database error: {str(e)}"}), 500

def process_csv_row(row, index):
    scryfall_id = row['Scryfall ID']
    card_name = row['Name']

    try:
        quantity = int(row['Quantity'])
        if quantity < 1:
            raise ValueError(f"Invalid quantity for card '{card_name}' at row {index + 2}.")
    except ValueError:
        raise ValueError(f"Invalid quantity for card '{card_name}' at row {index + 2}.")

    foil = row['Foil']
    if isinstance(foil, bool):
        foil_status = foil
    else:
        raise ValueError(f"Foil value must be boolean for card '{card_name}' at row {index + 2}.")

    card = Card.query.filter_by(id=scryfall_id).first()
    if not card:
        raise ValueError(f"Card with Scryfall ID '{scryfall_id}' not found in the database.")

    collection_item = Collection.query.filter_by(card_id=card.id).first()
    kiosk_item = Kiosk.query.filter_by(card_id=card.id).first()

    if foil_status:
        handle_foil_card(card, quantity, collection_item, kiosk_item)
    else:
        handle_non_foil_card(card, quantity, collection_item, kiosk_item)

def handle_foil_card(card, quantity, collection_item, kiosk_item):
    if collection_item and collection_item.quantity_foil > 0:
        if kiosk_item:
            kiosk_item.quantity_foil += quantity
        else:
            kiosk_item = Kiosk(card_id=card.id, quantity_foil=quantity)
            db.session.add(kiosk_item)
    else:
        to_collection = 1 if quantity >= 1 else 0
        to_kiosk = quantity - to_collection

        if to_collection > 0:
            if collection_item:
                collection_item.quantity_foil += to_collection
            else:
                collection_item = Collection(card_id=card.id, quantity_foil=to_collection)
                db.session.add(collection_item)

        if to_kiosk > 0:
            if kiosk_item:
                kiosk_item.quantity_foil += to_kiosk
            else:
                kiosk_item = Kiosk(card_id=card.id, quantity_foil=to_kiosk)
                db.session.add(kiosk_item)

def handle_non_foil_card(card, quantity, collection_item, kiosk_item):
    has_collection_copy = collection_item and (collection_item.quantity_regular > 0 or collection_item.quantity_foil > 0)

    if not has_collection_copy:
        to_collection = 1 if quantity >= 1 else 0
        to_kiosk = quantity - to_collection

        if to_collection > 0:
            if collection_item:
                collection_item.quantity_regular += to_collection
            else:
                collection_item = Collection(card_id=card.id, quantity_regular=to_collection)
                db.session.add(collection_item)

        if to_kiosk > 0:
            if kiosk_item:
                kiosk_item.quantity_regular += to_kiosk
            else:
                kiosk_item = Kiosk(card_id=card.id, quantity_regular=to_kiosk)
                db.session.add(kiosk_item)
    else:
        if kiosk_item:
            kiosk_item.quantity_regular += quantity
        else:
            kiosk_item = Kiosk(card_id=card.id, quantity_regular=quantity)
            db.session.add(kiosk_item)

== End of backend/routes/collection_routes.py ==

== Start of backend/routes/kiosk_routes.py ==
from flask import Blueprint, jsonify, request, current_app
from models.kiosk import Kiosk
from models.card import Card
from models.set import Set
from database import db
from sqlalchemy.sql import func, text
from sqlalchemy import distinct
import orjson

kiosk_routes = Blueprint('kiosk_routes', __name__)

def serialize_sets(sets):
    return [set_obj.to_dict() for set_obj in sets]

def serialize_cards(cards):
    return [{**card.to_dict(), 'quantity': kiosk_item.to_dict()} for card, kiosk_item in cards]

@kiosk_routes.route('/kiosk', methods=['GET'])
def get_kiosk():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)

    cache_key = f"kiosk:page:{page}:per_page:{per_page}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    kiosk = Kiosk.query.join(Card).paginate(page=page, per_page=per_page, error_out=False)

    result = {
        'kiosk': [
            {**item.card.to_dict(), 'quantity': item.to_dict()}
            for item in kiosk.items
        ],
        'total': kiosk.total,
        'pages': kiosk.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/sets', methods=['GET'])
def get_kiosk_sets():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    sort_by = request.args.get('sortBy', 'released_at')
    sort_order = request.args.get('sortOrder', 'desc')

    cache_key = f"kiosk_sets:page:{page}:per_page:{per_page}:sort_by:{sort_by}:sort_order:{sort_order}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    kiosk_sets = db.session.query(Set).\
        join(Card, Card.set_code == Set.code).\
        join(Kiosk, Kiosk.card_id == Card.id).\
        filter((Kiosk.quantity_regular > 0) | (Kiosk.quantity_foil > 0)).\
        distinct()

    if sort_order == 'desc':
        kiosk_sets = kiosk_sets.order_by(getattr(Set, sort_by).desc())
    else:
        kiosk_sets = kiosk_sets.order_by(getattr(Set, sort_by))

    paginated_sets = kiosk_sets.paginate(page=page, per_page=per_page, error_out=False)

    sets_data = []
    for set_obj in paginated_sets.items:
        set_dict = set_obj.to_dict()

        kiosk_count = db.session.query(func.count(distinct(Card.id))).\
            join(Kiosk, Kiosk.card_id == Card.id).\
            filter(Card.set_code == set_obj.code).\
            filter((Kiosk.quantity_regular > 0) | (Kiosk.quantity_foil > 0)).\
            scalar()

        set_dict['kiosk_count'] = kiosk_count
        set_dict['kiosk_percentage'] = (kiosk_count / set_obj.card_count) * 100 if set_obj.card_count > 0 else 0

        sets_data.append(set_dict)

    result = {
        'sets': sets_data,
        'total': paginated_sets.total,
        'pages': paginated_sets.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 600, serialized_data)  # Cache for 10 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/sets/<string:set_code>/cards', methods=['GET'])
def get_kiosk_set_cards(set_code):
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    name_filter = request.args.get('name', '')
    rarity_filter = request.args.get('rarity', '')
    sort_by = request.args.get('sortBy', 'name')
    sort_order = request.args.get('sortOrder', 'asc')

    cache_key = f"kiosk_set_cards:{set_code}:page:{page}:per_page:{per_page}:name:{name_filter}:rarity:{rarity_filter}:sort_by:{sort_by}:sort_order:{sort_order}"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    query = db.session.query(Card, Kiosk).\
        join(Kiosk, Kiosk.card_id == Card.id).\
        filter(Card.set_code == set_code).\
        filter((Kiosk.quantity_regular > 0) | (Kiosk.quantity_foil > 0))

    if name_filter:
        query = query.filter(Card.name.ilike(f'%{name_filter}%'))
    if rarity_filter:
        query = query.filter(Card.rarity == rarity_filter)

    if sort_order == 'desc':
        query = query.order_by(getattr(Card, sort_by).desc())
    else:
        query = query.order_by(getattr(Card, sort_by))

    paginated_cards = query.paginate(page=page, per_page=per_page, error_out=False)

    cards_data = []
    for card, kiosk_item in paginated_cards.items:
        card_dict = card.to_dict()
        card_dict['quantity'] = kiosk_item.to_dict()
        cards_data.append(card_dict)

    set_name = Set.query.filter_by(code=set_code).first().name

    result = {
        'cards': cards_data,
        'set_name': set_name,
        'total': paginated_cards.total,
        'pages': paginated_cards.pages,
        'current_page': page
    }

    serialized_data = orjson.dumps(result)
    current_app.redis_client.setex(cache_key, 300, serialized_data)  # Cache for 5 minutes

    return current_app.response_class(
        response=serialized_data,
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/<string:card_id>', methods=['POST', 'PUT'])
def update_kiosk(card_id):
    data = request.json
    quantity_regular = data.get('quantity_regular', 0)
    quantity_foil = data.get('quantity_foil', 0)

    kiosk_item = Kiosk.query.filter_by(card_id=card_id).first()

    if kiosk_item:
        kiosk_item.quantity_regular = quantity_regular
        kiosk_item.quantity_foil = quantity_foil
    else:
        kiosk_item = Kiosk(card_id=card_id, quantity_regular=quantity_regular, quantity_foil=quantity_foil)
        db.session.add(kiosk_item)

    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("kiosk:*")
    current_app.redis_client.delete("kiosk_sets:*")
    current_app.redis_client.delete(f"kiosk_set_cards:{kiosk_item.card.set_code}:*")

    return current_app.response_class(
        response=orjson.dumps(kiosk_item.to_dict()),
        status=200,
        mimetype='application/json'
    )

@kiosk_routes.route('/kiosk/<string:card_id>', methods=['DELETE'])
def remove_from_kiosk(card_id):
    kiosk_item = Kiosk.query.filter_by(card_id=card_id).first_or_404()
    set_code = kiosk_item.card.set_code
    db.session.delete(kiosk_item)
    db.session.commit()

    # Invalidate related caches
    current_app.redis_client.delete("kiosk:*")
    current_app.redis_client.delete("kiosk_sets:*")
    current_app.redis_client.delete(f"kiosk_set_cards:{set_code}:*")

    return '', 204

@kiosk_routes.route('/kiosk/stats', methods=['GET'])
def get_kiosk_stats():
    cache_key = "kiosk_stats"
    cached_data = current_app.redis_client.get(cache_key)

    if cached_data:
        return current_app.response_class(
            response=cached_data,
            status=200,
            mimetype='application/json'
        )

    try:
        total_cards = db.session.query(func.sum(Kiosk.quantity_regular + Kiosk.quantity_foil)).scalar() or 0
        unique_cards = Kiosk.query.count()

        total_value_query = text("""
            SELECT SUM(
                (CAST(COALESCE(NULLIF((prices::json->>'usd'), ''), '0') AS FLOAT) * kiosk.quantity_regular) +
                (CAST(COALESCE(NULLIF((prices::json->>'usd_foil'), ''), '0') AS FLOAT) * kiosk.quantity_foil)
            )
            FROM kiosk
            JOIN cards ON cards.id = kiosk.card_id
        """)
        total_value = db.session.execute(total_value_query).scalar() or 0

        result = {
            'total_cards': int(total_cards),
            'unique_cards': unique_cards,
            'total_value': round(total_value, 2)
        }

        serialized_data = orjson.dumps(result)
        current_app.redis_client.setex(cache_key, 3600, serialized_data)  # Cache for 1 hour

        return current_app.response_class(
            response=serialized_data,
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500
== End of backend/routes/kiosk_routes.py ==

== Start of backend/routes/set_routes.py ==
from flask import Blueprint, jsonify, request
from models.set import Set
from models.card import Card
from database import db
from sqlalchemy import asc, desc
from sqlalchemy.orm import joinedload

set_routes = Blueprint('set_routes', __name__)

@set_routes.route('/sets', methods=['GET'])
def get_all_sets():
    try:
        # Extract query parameters
        name = request.args.get('name', type=str, default='')
        set_type = request.args.get('set_type', type=str, default='')
        sort_by = request.args.get('sort_by', type=str, default='released_at')
        sort_order = request.args.get('sort_order', type=str, default='desc')
        page = request.args.get('page', type=int, default=1)
        per_page = request.args.get('per_page', type=int, default=20)

        query = Set.query

        # Apply filters
        if name:
            query = query.filter(Set.name.ilike(f'%{name}%'))
        if set_type:
            query = query.filter(Set.set_type == set_type)

        # Apply sorting
        if sort_order.lower() == 'asc':
            query = query.order_by(asc(getattr(Set, sort_by)))
        else:
            query = query.order_by(desc(getattr(Set, sort_by)))

        # Apply pagination
        paginated_sets = query.paginate(page=page, per_page=per_page, error_out=False)

        sets = [set.to_dict() for set in paginated_sets.items]

        return jsonify({
            'sets': sets,
            'total': paginated_sets.total,
            'pages': paginated_sets.pages,
            'current_page': paginated_sets.page
        }), 200
    except AttributeError:
        return jsonify({"error": f"Invalid sort_by field: {sort_by}"}), 400
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@set_routes.route('/sets/<string:set_code>', methods=['GET'])
def get_set(set_code):
    set_instance = Set.query.filter_by(code=set_code).first_or_404()
    return jsonify(set_instance.to_dict()), 200

@set_routes.route('/sets/<string:set_code>/cards', methods=['GET'])
def get_set_cards(set_code):
    # Extract filter parameters
    name_filter = request.args.get('name', '', type=str)
    rarity_filter = request.args.get('rarity', '', type=str)

    # Eagerly load related 'collection' and 'set' data to optimize queries
    query = Card.query.options(
        joinedload(Card.collection),
        joinedload(Card.set)
    ).filter(Card.set_code == set_code)

    # Apply filters based on query parameters
    if name_filter:
        query = query.filter(Card.name.ilike(f'%{name_filter}%'))
    if rarity_filter:
        query = query.filter(Card.rarity == rarity_filter)

    # Fetch all matching cards without pagination
    cards = query.all()

    # Serialize card data
    cards_data = []
    for card in cards:
        card_dict = {
            'id': card.id,
            'name': card.name,
            'rarity': card.rarity,
            'quantity_regular': card.collection.quantity_regular if card.collection else 0,
            'quantity_foil': card.collection.quantity_foil if card.collection else 0,
            'set_name': card.set.name if card.set else '',
            'set_code': card.set_code,
            'collector_number': card.collector_number,
            'mana_cost': card.mana_cost,
            'cmc': card.cmc,
            'type_line': card.type_line,
            'oracle_text': card.oracle_text,
            'colors': card.colors,
            'color_identity': card.color_identity,
            'keywords': card.keywords,
            'legalities': card.legalities,
            'reserved': card.reserved,
            'foil': card.foil,
            'nonfoil': card.nonfoil,
            'full_art': card.full_art,
            'textless': card.textless,
            'promo': card.promo,
            'reprint': card.reprint,
            'variation': card.variation,
            'artist': card.artist,
            'frame': card.frame,
            'border_color': card.border_color,
            'released_at': card.released_at,
            'prices': card.prices,
        }
        # Include image URIs
        if hasattr(card, 'image_uris') and card.image_uris:
            card_dict['image_uris'] = card.image_uris

        # Include related URIs
        if card.related_uris:
            card_dict['related_uris'] = card.related_uris

        # Include purchase URIs
        if card.purchase_uris:
            card_dict['purchase_uris'] = card.purchase_uris

        cards_data.append(card_dict)

    return jsonify({
        'cards': cards_data,
        'total': len(cards_data),
        'pages': 1,
        'current_page': 1
    }), 200

== End of backend/routes/set_routes.py ==

== Start of frontend/.eslintrc.js ==
module.exports = {
  root: true,
  parser: '@babel/eslint-parser',
  env: {
    node: true,
  },
  extends: [
    'plugin:vue/vue3-essential',
    'eslint:recommended',
  ],
  parserOptions: {
    requireConfigFile: false,
    ecmaVersion: 2020,
    sourceType: 'module',
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
  },
};
== End of frontend/.eslintrc.js ==

== Start of frontend/index.html ==
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MTG Collection Kiosk</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
== End of frontend/index.html ==

== Start of frontend/vite.config.js ==
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import tailwindcss from 'tailwindcss'
import autoprefixer from 'autoprefixer'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  css: {
    postcss: {
      plugins: [
        tailwindcss,
        autoprefixer,
      ],
    },
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
        secure: false,
      },
    },
  },
  build: {
    outDir: 'dist',
  },
})
== End of frontend/vite.config.js ==

== Start of frontend/src/App.vue ==
<template>
  <div id="app">
    <nav>
      <router-link to="/">Home</router-link>
      <router-link to="/collection">Collection</router-link>
      <router-link to="/kiosk">Kiosk</router-link>
      <router-link to="/sets">Sets</router-link>
      <router-link to="/import">Import</router-link>
    </nav>
    <router-view/>
  </div>
</template>

<script>
export default {
  name: 'App'
}
</script>

<style>
/* Styles are now handled in main.css */
</style>
== End of frontend/src/App.vue ==

== Start of frontend/src/main.js ==
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import axios from 'axios'

import './assets/main.css'

const app = createApp(App)

app.use(router)

// Configure Axios
axios.defaults.baseURL = import.meta.env.VITE_API_URL || 'http://localhost:5000'

// Make Axios available globally
app.config.globalProperties.$axios = axios

app.mount('#app')
== End of frontend/src/main.js ==

== frontend/src/router.js not found ==

== Start of frontend/src/assets/main.css ==
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Define CSS Variables for Dark Mode */
:root {
  --background-color: #121212;
  --text-color: #e0e0e0;
  --primary-color: #bb86fc;
  --secondary-color: #1f1f1f;
  --border-color: #333333;
  --input-background: #2c2c2c;
  --button-background: #333333;
  --button-hover-background: #444444;
  --link-color: #bb86fc;
  --error-color: #f44336;
  --success-color: #4caf50;
}

/* Apply Global Styles */
body {
  background-color: var(--background-color);
  color: var(--text-color);
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

*, *::before, *::after {
  box-sizing: inherit;
}

/* Link Styles */
a {
  color: var(--link-color);
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* Navigation Styles */
nav {
  background-color: var(--secondary-color);
  padding: 1rem;
  display: flex;
  justify-content: center;
  gap: 2rem;
}

nav a {
  color: var(--text-color);
  font-weight: bold;
}

nav a.router-link-exact-active {
  color: var(--primary-color);
}

/* Button Styles */
button {
  background-color: var(--button-background);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  padding: 0.5rem 1rem;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.3s ease;
}

button:hover {
  background-color: var(--button-hover-background);
}

button:disabled {
  background-color: #555555;
  cursor: not-allowed;
}

/* Form Elements */
input, select, textarea {
  background-color: var(--input-background);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  padding: 0.5rem;
  border-radius: 4px;
}

input::placeholder {
  color: #aaaaaa;
}

/* Card Styles */
.card {
  background-color: var(--secondary-color);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 1rem;
  color: var(--text-color);
  transition: transform 0.3s ease;
  height: auto; /* Let the card content determine the height */
  display: flex;
  flex-direction: column;
}

.card:hover {
  transform: scale(1.02);
}

/* Grid Layout */
.grid {
  display: grid;
  gap: 1rem;
}

.grid-cols-1 {
  grid-template-columns: 1fr;
}

.grid-cols-2 {
  grid-template-columns: repeat(2, 1fr);
}

.grid-cols-3 {
  grid-template-columns: repeat(3, 1fr);
}

.grid-cols-auto {
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
}

/* Flex Layout */
.flex {
  display: flex;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.justify-between {
  justify-content: space-between;
}

/* Progress Bars */
.progress-container {
  width: 100%;
  background-color: var(--border-color);
  border-radius: 10px;
  margin: 10px 0;
  overflow: hidden;
}

.progress-bar {
  height: 10px;
  transition: width 0.5s ease-in-out;
}

/* Message Styles */
.message {
  margin-top: 1rem;
  padding: 1rem;
  border-radius: 4px;
}

.message.success {
  background-color: var(--success-color);
  color: #ffffff;
}

.message.error {
  background-color: var(--error-color);
  color: #ffffff;
}

/* Containers */
.container {
  width: 100%;
  max-width: 100%;
  margin: 0 auto;
  padding: 1rem;
  box-sizing: border-box;
}

/* Utility Classes */
.text-center {
  text-align: center;
}

.mt-1 { margin-top: 0.25rem; }
.mt-2 { margin-top: 0.5rem; }
.mt-3 { margin-top: 1rem; }
.mt-4 { margin-top: 1.5rem; }

.mb-1 { margin-bottom: 0.25rem; }
.mb-2 { margin-bottom: 0.5rem; }
.mb-3 { margin-bottom: 1rem; }
.mb-4 { margin-bottom: 1.5rem; }

.ml-1 { margin-left: 0.25rem; }
.ml-2 { margin-left: 0.5rem; }
.ml-3 { margin-left: 1rem; }
.ml-4 { margin-left: 1.5rem; }

.mr-1 { margin-right: 0.25rem; }
.mr-2 { margin-right: 0.5rem; }
.mr-3 { margin-right: 1rem; }
.mr-4 { margin-right: 1.5rem; }

.p-1 { padding: 0.25rem; }
.p-2 { padding: 0.5rem; }
.p-3 { padding: 1rem; }
.p-4 { padding: 1.5rem; }

.w-full {
  width: 100%;
}

.h-full {
  height: 100%;
}

/* Responsive image */
.img-responsive {
  max-width: 100%;
  height: auto;
  display: block;
  object-fit: contain;
}

/* Ensure all images and icons are compatible with dark mode */
img {
  max-width: 100%;
  height: auto;
}

/* Quantity Control Styles */
.quantity-control {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
}

.quantity-input {
  width: 60px;
  text-align: center;
}

/* Card Content Styles */
.card-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
}

.card-image-container {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.card-details {
  margin-top: auto;
}
== End of frontend/src/assets/main.css ==

== Start of frontend/src/components/SetListControls.vue ==
<template>
  <div class="controls grid grid-cols-1 md:grid-cols-3 gap-1 mb-2">
    <div class="filter-section">
      <input
        v-model="localFilters.name"
        @input="emitFilters"
        placeholder="Search by name"
      />
      <select v-model="localFilters.set_type" @change="emitFilters">
        <option value="">All Types</option>
        <option v-for="type in setTypes" :key="type" :value="type">{{ capitalize(type) }}</option>
      </select>
    </div>
    <div class="sort-section">
      <label for="sortBy">Sort By:</label>
      <select v-model="localSorting.sortBy" @change="emitSorting" id="sortBy">
        <option value="released_at">Release Date</option>
        <option value="name">Name</option>
        <option value="collection_count">Collection Count</option>
      </select>
      <select v-model="localSorting.sortOrder" @change="emitSorting">
        <option value="asc">Ascending</option>
        <option value="desc">Descending</option>
      </select>
    </div>
    <div class="pagination-section">
      <label for="perPage">Per Page:</label>
      <select v-model="localPerPage" @change="emitPerPage" id="perPage">
        <option v-for="option in perPageOptions" :key="option" :value="option">{{ option }}</option>
      </select>
    </div>
  </div>
</template>

<script>
export default {
  name: 'SetListControls',
  props: {
    setTypes: {
      type: Array,
      required: true
    },
    totalPages: {
      type: Number,
      required: true
    }
  },
  data() {
    return {
      localFilters: {
        name: '',
        set_type: ''
      },
      localSorting: {
        sortBy: 'released_at',
        sortOrder: 'desc'
      },
      localPerPage: 20,
      perPageOptions: [10, 20, 50, 100]
    }
  },
  methods: {
    emitFilters() {
      this.$emit('update-filters', { ...this.localFilters })
    },
    emitSorting() {
      this.$emit('update-sorting', { ...this.localSorting })
    },
    emitPerPage() {
      this.$emit('update-per-page', this.localPerPage)
    },
    capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1)
    }
  }
}
</script>

<style scoped>
.controls label {
  margin-right: 0.5rem;
}
</style>
== End of frontend/src/components/SetListControls.vue ==

== Start of frontend/src/router/index.js ==
import { createRouter, createWebHistory } from 'vue-router'
import Home from '../views/Home.vue'
import Collection from '../views/Collection.vue'
import CollectionSetCards from '../views/CollectionSetCards.vue'
import Kiosk from '../views/Kiosk.vue'
import KioskSetCards from '../views/KioskSetCards.vue'
import Import from '../views/Import.vue'
import Sets from '../views/Sets.vue'
import SetDetails from '../views/SetDetails.vue'

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home
  },
  {
    path: '/collection',
    name: 'Collection',
    component: Collection
  },
  {
    path: '/collection/sets/:setCode',
    name: 'CollectionSetCards',
    component: CollectionSetCards,
    props: true
  },
  {
    path: '/kiosk',
    name: 'Kiosk',
    component: Kiosk
  },
  {
    path: '/kiosk/sets/:setCode',
    name: 'KioskSetCards',
    component: KioskSetCards,
    props: true
  },
  {
    path: '/import',
    name: 'Import',
    component: Import
  },
  {
    path: '/sets',
    name: 'Sets',
    component: Sets
  },
  {
    path: '/sets/:setCode',
    name: 'SetDetails',
    component: SetDetails,
    props: true
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
})

export default router
== End of frontend/src/router/index.js ==

== Start of frontend/src/views/Collection.vue ==
<template>
  <div class="container">
    <h1 class="text-center mb-2">My Collection</h1>
    <div v-if="stats" class="collection-stats card grid grid-cols-3 mb-2">
      <div class="stat">
        <h2>Total Cards</h2>
        <p>{{ stats.total_cards }}</p>
      </div>
      <div class="stat">
        <h2>Unique Cards</h2>
        <p>{{ stats.unique_cards }}</p>
      </div>
      <div class="stat">
        <h2>Total Value</h2>
        <p>${{ stats.total_value.toFixed(2) }}</p>
      </div>
    </div>
    <SetListControls
      :setTypes="setTypes"
      :totalPages="totalPages"
      @update-filters="updateFilters"
      @update-sorting="updateSorting"
      @update-per-page="updatePerPage"
    />
    <div v-if="loading" class="loading text-center mt-1">Loading...</div>
    <div v-else-if="error" class="error text-center mt-1">{{ error }}</div>
    <div v-else-if="sets && sets.length > 0" class="set-grid grid grid-cols-auto">
      <div v-for="set in sets" :key="set.code" class="card">
        <router-link :to="{ name: 'CollectionSetCards', params: { setCode: set.code } }">
          <div class="set-icon">
            <img :src="set.icon_svg_uri" :alt="set.name" />
          </div>
          <h3>{{ set.name }}</h3>
          <p>Code: {{ set.code }}</p>
          <p>Type: {{ set.set_type }}</p>
          <p>Released: {{ formatDate(set.released_at) }}</p>
          <p>Collection: {{ set.collection_count }} / {{ set.card_count }}</p>
          <p>Completion: {{ Math.round(set.collection_percentage) }}%</p>
          <div class="progress-container">
            <div
              class="progress-bar"
              :style="{ width: `${set.collection_percentage}%`, backgroundColor: getProgressColor(set.collection_percentage) }"
            ></div>
          </div>
        </router-link>
      </div>
    </div>
    <div v-else-if="!loading && sets.length === 0" class="text-center mt-1">
      <p>No sets found in your collection.</p>
    </div>
    <div class="pagination text-center mt-2">
      <button @click="changePage(-1)" :disabled="currentPage === 1">Previous</button>
      <span class="p-1">Page {{ currentPage }} of {{ totalPages }}</span>
      <button @click="changePage(1)" :disabled="currentPage === totalPages">Next</button>
    </div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import axios from 'axios'
import SetListControls from '../components/SetListControls.vue'

export default {
  name: 'Collection',
  components: {
    SetListControls
  },
  setup() {
    const sets = ref([])
    const stats = ref(null)
    const loading = ref(true)
    const error = ref(null)
    const filters = ref({})
    const sorting = ref({ sortBy: 'released_at', sortOrder: 'desc' })
    const currentPage = ref(1)
    const totalPages = ref(1)
    const perPage = ref(20)
    const setTypes = ref([
      'core', 'expansion', 'masters', 'draft_innovation', 'funny',
      'starter', 'box', 'promo', 'token', 'memorabilia'
    ])

    const fetchStats = async () => {
      try {
        const response = await axios.get('/api/collection/stats')
        stats.value = response.data
      } catch (err) {
        console.error('Error fetching collection stats:', err)
        error.value = 'Failed to load collection stats'
      }
    }

    const fetchSets = async () => {
      loading.value = true
      error.value = null
      try {
        const response = await axios.get('/api/collection/sets', {
          params: {
            ...filters.value,
            ...sorting.value,
            page: currentPage.value,
            per_page: perPage.value
          }
        })
        sets.value = response.data.sets
        totalPages.value = response.data.pages
        currentPage.value = response.data.current_page
      } catch (err) {
        console.error('Error fetching collection sets:', err)
        error.value = 'Failed to load collection sets'
      } finally {
        loading.value = false
      }
    }

    const updateFilters = (newFilters) => {
      filters.value = { ...filters.value, ...newFilters }
      currentPage.value = 1
      fetchSets()
    }

    const updateSorting = (newSorting) => {
      sorting.value = { ...newSorting }
      fetchSets()
    }

    const updatePerPage = (newPerPage) => {
      perPage.value = newPerPage
      currentPage.value = 1
      fetchSets()
    }

    const changePage = (delta) => {
      const newPage = currentPage.value + delta
      if (newPage >= 1 && newPage <= totalPages.value) {
        currentPage.value = newPage
        fetchSets()
      }
    }

    const formatDate = (dateString) => {
      return new Date(dateString).toLocaleDateString()
    }

    const getProgressColor = (percentage) => {
      if (percentage < 25) return '#f44336'
      if (percentage < 50) return '#ff9800'
      if (percentage < 75) return '#ffc107'
      return '#4caf50'
    }

    onMounted(() => {
      fetchStats()
      fetchSets()
    })

    return {
      sets,
      stats,
      loading,
      error,
      filters,
      sorting,
      currentPage,
      totalPages,
      perPage,
      setTypes,
      updateFilters,
      updateSorting,
      updatePerPage,
      changePage,
      formatDate,
      getProgressColor
    }
  }
}
</script>

<style scoped>
.collection-stats .stat {
  text-align: center;
}

.set-icon {
  width: 50px;
  height: 50px;
  margin: 0 auto 1rem;
}

.set-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}
</style>
== End of frontend/src/views/Collection.vue ==

== Start of frontend/src/views/CollectionSetCards.vue ==
<template>
  <div class="min-h-screen bg-gray-900 text-white p-6">
    <!-- Header Section -->
    <h1 class="text-4xl font-bold text-center mb-2">Duskmourn: House of Horror</h1>
    <p class="text-center text-gray-400 mb-4">(Part of Gluthorice's collection)</p>

    <!-- SVG Icon -->
    <div class="flex justify-center items-center mb-8">
      <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 2L2 7L12 12L22 7L12 2Z"/>
        <path d="M2 17L12 22L22 17"/>
        <path d="M2 12L12 17L22 12"/>
      </svg>
    </div>

    <!-- Progress Section -->
    <div class="text-center mb-8">
      <h2 class="text-3xl font-bold">{{ collectedCards }}/{{ totalCards }}</h2>
      <p class="text-sm text-gray-400">({{ collectedCards }} total cards collected)</p>
      <p class="text-sm text-gray-400">Set value: ${{ setValue.toFixed(2) }}</p>
    </div>

    <div class="w-full bg-blue-900 h-2 mb-8">
      <div class="bg-blue-500 h-2" :style="{ width: `${completionPercentage}%` }"></div>
    </div>

    <!-- Controls Section -->
    <div class="flex justify-between items-center mb-4">
      <!-- Pagination Controls -->
      <div class="flex items-center">
        <button @click="previousPage" class="mr-2 p-1 bg-gray-700 rounded">
          <ChevronLeftIcon />
        </button>
        <span class="mx-2">{{ currentPage }}</span>
        <button @click="nextPage" class="ml-2 p-1 bg-gray-700 rounded">
          <ChevronRightIcon />
        </button>
      </div>

      <!-- Card Size Slider -->
      <div class="flex items-center">
        <span class="mr-2">Card size</span>
        <input type="range" v-model="cardSize" min="100" max="300" class="w-32" />
      </div>

      <!-- Cards Per Row Slider -->
      <div class="flex items-center">
        <span class="mr-2">Cards per row</span>
        <input type="range" v-model="cardsPerRow" min="1" max="10" class="w-32" />
      </div>

      <!-- Settings Button -->
      <button class="p-1 bg-gray-700 rounded" @click="openSettings">
        <SettingsIcon />
      </button>
    </div>

    <!-- Filters Section (from CollectionSetCards.vue) -->
    <div class="filters grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
      <input
        v-model="nameFilter"
        @input="applyFilters"
        placeholder="Filter by name"
        class="p-2 border rounded bg-gray-800 text-white"
      />
      <select v-model="rarityFilter" @change="applyFilters" class="p-2 border rounded bg-gray-800 text-white">
        <option value="">All Rarities</option>
        <option value="common">Common</option>
        <option value="uncommon">Uncommon</option>
        <option value="rare">Rare</option>
        <option value="mythic">Mythic</option>
      </select>
    </div>

    <!-- Card Grid -->
    <div class="grid gap-4" :style="{ gridTemplateColumns: `repeat(${cardsPerRow}, minmax(0, 1fr))` }">
      <div
        v-for="card in sortedCards"
        :key="card.id"
        class="bg-gray-800 rounded-lg overflow-hidden relative"
        :class="{ 'border-2 border-red-500': isMissing(card) }"
        :style="{ width: `${cardSize}px` }"
      >
        <!-- Card Image -->
        <div class="image-container" :style="{ height: `${cardSize}px` }">
          <img
            v-if="getImageUrl(card)"
            :src="getImageUrl(card)"
            :alt="card.name"
            class="w-full h-full object-contain"
            @error="handleImageError($event, card)"
          />
          <div v-else class="w-full h-full flex items-center justify-center bg-gray-200 text-gray-500">
            No image available
          </div>
        </div>

        <!-- Card Info -->
        <div class="p-4">
          <h3 class="text-lg font-semibold mb-2">{{ card.name }}</h3>
          <div class="flex justify-between mb-2">
            <span>Regular: {{ card.quantity_regular }}</span>
            <span>Foil: {{ card.quantity_foil }}</span>
          </div>
          <div class="text-sm text-gray-400">
            <p>${{ card.price_regular }} (${{ card.price_foil }} foil)</p>
          </div>
        </div>

        <!-- Quantity Controls -->
        <div class="card-quantities grid grid-cols-2 gap-2 p-4">
          <!-- Regular Quantity Control -->
          <div class="quantity-control flex flex-col">
            <label :for="'regular-' + card.id" class="quantity-label mb-1 text-sm font-semibold">
              Regular
            </label>
            <div class="input-wrapper flex border rounded-md overflow-hidden">
              <input
                :id="'regular-' + card.id"
                v-model.number="card.quantity_regular"
                type="number"
                min="0"
                class="quantity-input flex-1 p-2 text-center border-none outline-none bg-gray-700 text-white"
                @input="onInput(card, 'regular')"
              />
              <div class="buttons flex flex-col bg-gray-600 border-l">
                <button
                  @click="increment(card, 'regular')"
                  class="btn increment-btn px-2 py-1 text-sm bg-gray-500 hover:bg-gray-400"
                  aria-label="Increment Regular Quantity"
                >
                  
                </button>
                <button
                  @click="decrement(card, 'regular')"
                  class="btn decrement-btn px-2 py-1 text-sm bg-gray-500 hover:bg-gray-400"
                  aria-label="Decrement Regular Quantity"
                  :disabled="card.quantity_regular === 0"
                >
                  
                </button>
              </div>
            </div>
          </div>

          <!-- Foil Quantity Control -->
          <div class="quantity-control flex flex-col">
            <label :for="'foil-' + card.id" class="quantity-label mb-1 text-sm font-semibold">
              Foil
            </label>
            <div class="input-wrapper flex border rounded-md overflow-hidden">
              <input
                :id="'foil-' + card.id"
                v-model.number="card.quantity_foil"
                type="number"
                min="0"
                class="quantity-input flex-1 p-2 text-center border-none outline-none bg-gray-700 text-white"
                @input="onInput(card, 'foil')"
              />
              <div class="buttons flex flex-col bg-gray-600 border-l">
                <button
                  @click="increment(card, 'foil')"
                  class="btn increment-btn px-2 py-1 text-sm bg-gray-500 hover:bg-gray-400"
                  aria-label="Increment Foil Quantity"
                >
                  
                </button>
                <button
                  @click="decrement(card, 'foil')"
                  class="btn decrement-btn px-2 py-1 text-sm bg-gray-500 hover:bg-gray-400"
                  aria-label="Decrement Foil Quantity"
                  :disabled="card.quantity_foil === 0"
                >
                  
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Missing Indicator -->
        <div v-if="isMissing(card)" class="missing-indicator absolute top-2 right-2 bg-red-500 text-white px-2 py-1 rounded text-xs font-bold">
          Missing
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted } from 'vue';
import { ChevronLeftIcon, ChevronRightIcon, SettingsIcon } from 'lucide-vue-next';
import axios from 'axios';
import { useRoute } from 'vue-router';

// Reactive References
const route = useRoute();
const setCode = ref(route.params.setCode);
const setName = ref('');
const cards = ref([]);
const loading = ref(true);
const error = ref(null);
const nameFilter = ref('');
const rarityFilter = ref('');

// Control States
const cardSize = ref(200); // Default card size
const cardsPerRow = ref(5);
const currentPage = ref(1); // Assuming pagination
const collectedCards = ref(0);
const totalCards = ref(0);
const setValue = ref(0.0);

// Computed Properties
const completionPercentage = computed(() => {
  return totalCards.value > 0 ? (collectedCards.value / totalCards.value) * 100 : 0;
});

const sortedCards = computed(() => {
  return cards.value.slice().sort((a, b) => {
    if (!a.collector_number && !b.collector_number) return 0;
    if (!a.collector_number) return 1;
    if (!b.collector_number) return -1;

    const numA = parseInt(a.collector_number, 10);
    const numB = parseInt(b.collector_number, 10);

    if (!isNaN(numA) && !isNaN(numB)) {
      return numA - numB;
    }
    return a.collector_number.localeCompare(b.collector_number);
  });
});

// Fetch Cards Function
const fetchCards = async () => {
  loading.value = true;
  error.value = null;
  try {
    const response = await axios.get(`/api/sets/${setCode.value}/cards`, {
      params: {
        name: nameFilter.value,
        rarity: rarityFilter.value,
        page: currentPage.value,
      },
    });
    cards.value = response.data.cards;
    setName.value = response.data.set_name || 'Set Name';
    collectedCards.value = response.data.collected_cards || 0;
    totalCards.value = response.data.total_cards || 0;
    setValue.value = response.data.set_value || 0.0;
  } catch (err) {
    console.error('Error fetching set cards:', err);
    error.value = 'Failed to load set cards';
  } finally {
    loading.value = false;
  }
};

// Watchers
watch(
  () => route.params.setCode,
  (newSetCode) => {
    setCode.value = newSetCode;
    fetchCards();
  }
);

// Lifecycle Hook
onMounted(() => {
  fetchCards();
});

// Methods
const applyFilters = () => {
  currentPage.value = 1; // Reset to first page on filter change
  fetchCards();
};

const isMissing = (card) => {
  return card.quantity_regular + card.quantity_foil === 0;
};

const getImageUrl = (card) => {
  const imageSizes = ['normal', 'large', 'small', 'png', 'art_crop', 'border_crop'];

  if (card.image_uris) {
    for (const size of imageSizes) {
      if (card.image_uris[size]) {
        return card.image_uris[size];
      }
    }
  }

  if (card.card_faces && card.card_faces[0].image_uris) {
    for (const size of imageSizes) {
      if (card.card_faces[0].image_uris[size]) {
        return card.card_faces[0].image_uris[size];
      }
    }
  }

  console.warn('No image URL found for card:', card.name);
  return null;
};

const handleImageError = (event, card) => {
  console.error('Image failed to load for card:', card.name, 'URL:', event.target.src);
  event.target.style.display = 'none';
  const noImageDiv = event.target.parentNode.querySelector('.bg-gray-200');
  if (noImageDiv) {
    noImageDiv.style.display = 'flex';
  }
};

const updateQuantity = async (card) => {
  try {
    const response = await axios.put(`/api/collection/${card.id}`, {
      quantity_regular: card.quantity_regular,
      quantity_foil: card.quantity_foil,
    });
    // Update the local card data
    const index = cards.value.findIndex((c) => c.id === card.id);
    if (index !== -1) {
      cards.value[index] = response.data;
      // Optionally update collectedCards and setValue here
    }
  } catch (err) {
    console.error('Error updating quantity:', err);
    alert('Failed to update quantity. Please try again.');
    // Optionally revert the quantity change
    fetchCards();
  }
};

const increment = (card, type) => {
  if (type === 'regular') {
    card.quantity_regular += 1;
  } else if (type === 'foil') {
    card.quantity_foil += 1;
  }
  updateQuantity(card);
};

const decrement = (card, type) => {
  if (type === 'regular' && card.quantity_regular > 0) {
    card.quantity_regular -= 1;
    updateQuantity(card);
  } else if (type === 'foil' && card.quantity_foil > 0) {
    card.quantity_foil -= 1;
    updateQuantity(card);
  }
};

const onInput = (card, type) => {
  if (type === 'regular') {
    card.quantity_regular = Math.max(0, parseInt(card.quantity_regular) || 0);
  } else if (type === 'foil') {
    card.quantity_foil = Math.max(0, parseInt(card.quantity_foil) || 0);
  }
  updateQuantity(card);
};

const previousPage = () => {
  if (currentPage.value > 1) {
    currentPage.value -= 1;
    fetchCards();
  }
};

const nextPage = () => {
  currentPage.value += 1;
  fetchCards();
};

const openSettings = () => {
  // Implement settings modal or functionality
  alert('Settings clicked');
};
</script>

<style scoped>
/* Additional Styles */
.image-container {
  width: 100%;
  overflow: hidden;
}

.quantity-label {
  font-size: 0.85rem;
}

.quantity-input {
  -webkit-appearance: textfield;
  -moz-appearance: textfield;
  appearance: textfield;
}

.quantity-input::-webkit-inner-spin-button,
.quantity-input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.buttons button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.missing-indicator {
  position: absolute;
  top: 8px;
  right: 8px;
}

.filters input,
.filters select {
  background-color: #2d3748; /* Tailwind's bg-gray-800 */
  color: #fff;
}

.card-quantities {
  margin-top: auto;
}
</style>

== End of frontend/src/views/CollectionSetCards.vue ==

== Start of frontend/src/views/Home.vue ==
<template>
  <div class="container">
    <h1 class="text-center mb-4">MTG Collection Manager</h1>
    <div class="dashboard grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
      <div class="card text-center">
        <h2 class="mb-2">Total Cards</h2>
        <p class="text-2xl font-bold">{{ stats.totalCards }}</p>
      </div>
      <div class="card text-center">
        <h2 class="mb-2">Unique Cards</h2>
        <p class="text-2xl font-bold">{{ stats.uniqueCards }}</p>
      </div>
      <div class="card text-center">
        <h2 class="mb-2">Sets Collected</h2>
        <p class="text-2xl font-bold">{{ stats.setsCollected }}</p>
      </div>
    </div>
    <div class="text-center">
      <button @click="refreshStats" class="px-4 py-2">Refresh Stats</button>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from 'vue'
import axios from 'axios'

export default {
  name: 'Home',
  setup() {
    const stats = ref({
      totalCards: 0,
      uniqueCards: 0,
      setsCollected: 0
    })
    let refreshInterval

    const fetchStats = async () => {
      try {
        const response = await axios.get('/api/stats')
        stats.value = response.data
      } catch (error) {
        console.error('Failed to fetch stats:', error)
      }
    }

    const refreshStats = () => {
      fetchStats()
    }

    onMounted(() => {
      fetchStats()
      refreshInterval = setInterval(fetchStats, 300000) // Refresh every 5 minutes
    })

    onUnmounted(() => {
      clearInterval(refreshInterval)
    })

    return {
      stats,
      refreshStats
    }
  }
}
</script>
== End of frontend/src/views/Home.vue ==

== Start of frontend/src/views/Import.vue ==
<template>
  <div class="container">
    <h1 class="text-center mb-4">Import Cards</h1>

    <div class="card mb-4">
      <h2 class="mb-2">Import Single Card</h2>
      <form @submit.prevent="importSingleCard" class="grid grid-cols-1 gap-2">
        <div>
          <label for="scryfallId" class="block mb-1">Scryfall ID:</label>
          <input v-model="singleCard.scryfallId" id="scryfallId" required class="w-full">
        </div>
        <div>
          <label for="quantity" class="block mb-1">Quantity:</label>
          <input v-model.number="singleCard.quantity" id="quantity" type="number" min="1" required class="w-full">
        </div>
        <div class="flex items-center">
          <input v-model="singleCard.foil" id="foil" type="checkbox" class="mr-2">
          <label for="foil">Foil</label>
        </div>
        <div>
          <label for="destination" class="block mb-1">Destination:</label>
          <select v-model="singleCard.destination" id="destination" required class="w-full">
            <option value="collection">Collection</option>
            <option value="kiosk">Kiosk</option>
          </select>
        </div>
        <button type="submit" class="mt-2">Import Card</button>
      </form>
    </div>

    <div class="card mb-4">
      <h2 class="mb-2">CSV Import Guidelines</h2>
      <p class="mb-2">Please ensure your CSV follows the format below:</p>
      <pre class="bg-secondary p-2 mb-2 overflow-auto text-sm font-mono whitespace-pre-wrap break-words">
Name,Edition,Edition code,Collector's number,Price,Foil,Currency,Scryfall ID,Quantity
"Saw","Duskmourn: House of Horror","DSK","254","$0.21","Foil","USD","603c3ef4-4ef1-4db8-9ed2-e2b0926269d5","2"
      </pre>
      <a href="/static/csv_template.csv" download="csv_template.csv" class="text-primary hover:underline">Download CSV Template</a>
    </div>

    <div class="card mb-4">
      <h2 class="mb-2">Import from CSV</h2>
      <form @submit.prevent="importFromCSV" class="grid grid-cols-1 gap-2">
        <div>
          <label for="csvFile" class="block mb-1">CSV File:</label>
          <input type="file" id="csvFile" @change="handleFileUpload" accept=".csv" required class="w-full">
        </div>
        <button type="submit" class="mt-2">Import CSV</button>
      </form>
    </div>

    <div v-if="message" :class="['message', messageType, 'p-2 rounded']">
      {{ message }}
    </div>
  </div>
</template>

<script>
import { ref } from 'vue'
import axios from 'axios'

export default {
  name: 'Import',
  setup() {
    const singleCard = ref({
      scryfallId: '',
      quantity: 1,
      foil: false,
      destination: 'collection'
    })

    const csvImport = ref({
      file: null
    })

    const message = ref('')
    const messageType = ref('')

    const importSingleCard = async () => {
      try {
        const response = await axios.post(`/api/collection`, {
          scryfall_id: singleCard.value.scryfallId,
          quantity: singleCard.value.quantity,
          foil: singleCard.value.foil ? 1 : 0
        })
        message.value = `Card imported successfully: ${response.data.message}`
        messageType.value = 'success'
        // Reset form
        singleCard.value = { scryfallId: '', quantity: 1, foil: false, destination: 'collection' }
      } catch (error) {
        message.value = `Error importing card: ${error.response?.data?.error || error.message}`
        messageType.value = 'error'
      }
    }

    const handleFileUpload = (event) => {
      csvImport.value.file = event.target.files[0]
    }

    const importFromCSV = async () => {
      if (!csvImport.value.file) {
        message.value = 'Please select a CSV file'
        messageType.value = 'error'
        return
      }

      const formData = new FormData()
      formData.append('file', csvImport.value.file)

      try {
        const response = await axios.post('/api/collection/import_csv', formData, {
          headers: {
            'Content-Type': 'multipart/form-data'
          }
        })
        message.value = `CSV imported successfully: ${response.data.message}`
        messageType.value = 'success'
        // Reset form
        csvImport.value = { file: null }
      } catch (error) {
        message.value = `Error importing CSV: ${error.response?.data?.error || error.message}`
        messageType.value = 'error'
      }
    }

    return {
      singleCard,
      csvImport,
      message,
      messageType,
      importSingleCard,
      handleFileUpload,
      importFromCSV
    }
  }
}
</script>
== End of frontend/src/views/Import.vue ==

== Start of frontend/src/views/Kiosk.vue ==
<!-- Kiosk.vue -->
<template>
  <div class="container">
    <h1 class="text-center mb-2">Kiosk Inventory</h1>
    <SetListControls
      :setTypes="setTypes"
      :totalPages="totalPages"
      @update-filters="updateFilters"
      @update-sorting="updateSorting"
      @update-per-page="updatePerPage"
    />
    <div v-if="loading" class="loading text-center mt-1">Loading...</div>
    <div v-else-if="error" class="error text-center mt-1">{{ error }}</div>
    <div v-else-if="sets && sets.length > 0" class="set-grid grid grid-cols-auto">
      <div v-for="set in sets" :key="set.code" class="card">
        <router-link :to="{ name: 'KioskSetCards', params: { setCode: set.code } }">
          <div class="set-icon">
            <img :src="set.icon_svg_uri" :alt="set.name" />
          </div>
          <h3>{{ set.name }}</h3>
          <p>Code: {{ set.code }}</p>
          <p>Type: {{ set.set_type }}</p>
          <p>Released: {{ formatDate(set.released_at) }}</p>
          <p>Kiosk Cards: {{ set.kiosk_count }} / {{ set.card_count }}</p>
          <p>Completion: {{ Math.round(set.kiosk_percentage) }}%</p>
          <div class="progress-container">
            <div
              class="progress-bar"
              :style="{ width: `${set.kiosk_percentage}%`, backgroundColor: getProgressColor(set.kiosk_percentage) }"
            ></div>
          </div>
        </router-link>
      </div>
    </div>
    <div v-else-if="!loading && sets.length === 0" class="text-center mt-1">
      <p>No sets found in your kiosk inventory.</p>
    </div>
    <div class="pagination text-center mt-2">
      <button @click="changePage(-1)" :disabled="currentPage === 1">Previous</button>
      <span class="p-1">Page {{ currentPage }} of {{ totalPages }}</span>
      <button @click="changePage(1)" :disabled="currentPage === totalPages">Next</button>
    </div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import axios from 'axios'
import SetListControls from '../components/SetListControls.vue'

export default {
  name: 'Kiosk',
  components: {
    SetListControls
  },
  setup() {
    const sets = ref([])
    const loading = ref(true)
    const error = ref(null)
    const filters = ref({})
    const sorting = ref({ sortBy: 'released_at', sortOrder: 'desc' })
    const currentPage = ref(1)
    const totalPages = ref(1)
    const perPage = ref(20)
    const setTypes = ref([
      'core', 'expansion', 'masters', 'draft_innovation', 'funny',
      'starter', 'box', 'promo', 'token', 'memorabilia'
    ])

    const fetchSets = async () => {
      loading.value = true
      error.value = null
      try {
        const response = await axios.get('/api/kiosk/sets', {
          params: {
            ...filters.value,
            ...sorting.value,
            page: currentPage.value,
            per_page: perPage.value
          }
        })
        sets.value = response.data.sets
        totalPages.value = response.data.pages
        currentPage.value = response.data.current_page
      } catch (err) {
        console.error('Error fetching kiosk sets:', err)
        error.value = 'Failed to load kiosk sets'
      } finally {
        loading.value = false
      }
    }

    const updateFilters = (newFilters) => {
      filters.value = { ...filters.value, ...newFilters }
      currentPage.value = 1
      fetchSets()
    }

    const updateSorting = (newSorting) => {
      sorting.value = { ...newSorting }
      fetchSets()
    }

    const updatePerPage = (newPerPage) => {
      perPage.value = newPerPage
      currentPage.value = 1
      fetchSets()
    }

    const changePage = (delta) => {
      const newPage = currentPage.value + delta
      if (newPage >= 1 && newPage <= totalPages.value) {
        currentPage.value = newPage
        fetchSets()
      }
    }

    const formatDate = (dateString) => {
      return new Date(dateString).toLocaleDateString()
    }

    const getProgressColor = (percentage) => {
      if (percentage < 25) return '#f44336'
      if (percentage < 50) return '#ff9800'
      if (percentage < 75) return '#ffc107'
      return '#4caf50'
    }

    onMounted(() => {
      fetchSets()
    })

    return {
      sets,
      loading,
      error,
      filters,
      sorting,
      currentPage,
      totalPages,
      perPage,
      setTypes,
      updateFilters,
      updateSorting,
      updatePerPage,
      changePage,
      formatDate,
      getProgressColor
    }
  }
}
</script>

<style scoped>
.set-icon {
  width: 50px;
  height: 50px;
  margin: 0 auto 1rem;
}

.set-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}
</style>
== End of frontend/src/views/Kiosk.vue ==

== Start of frontend/src/views/SetDetails.vue ==
<template>
  <div class="container">
    <div v-if="set" class="set-info text-center mb-6">
      <img :src="set.icon_svg_uri" :alt="set.name" class="set-icon w-24 h-24 mx-auto mb-4">
      <h1 class="text-2xl font-bold mb-2">{{ set.name }}</h1>
      <p class="mb-1">Code: {{ set.code }}</p>
      <p class="mb-1">Released: {{ new Date(set.released_at).toLocaleDateString() }}</p>
      <p class="mb-1">Card Count: {{ set.card_count }}</p>
      <p>Set Type: {{ set.set_type }}</p>
    </div>

    <h2 class="text-xl font-bold text-center mb-4">Cards in this Set</h2>
    <div class="filters grid grid-cols-1 md:grid-cols-2 gap-2 mb-4">
      <input v-model="filters.name" placeholder="Search by card name" @input="fetchCards" class="w-full p-2">
      <select v-model="filters.rarity" @change="fetchCards" class="w-full p-2">
        <option value="">All Rarities</option>
        <option value="common">Common</option>
        <option value="uncommon">Uncommon</option>
        <option value="rare">Rare</option>
        <option value="mythic">Mythic</option>
      </select>
    </div>

    <div class="card-list grid grid-cols-auto gap-4">
      <div v-for="card in cards" :key="card.id" class="card">
        <img :src="card.image_uris.small" :alt="card.name" class="w-full mb-2">
        <div class="card-details p-2">
          <h3 class="text-lg font-semibold mb-2">{{ card.name }}</h3>
          <p class="mb-1"><span class="font-medium">Rarity:</span> {{ card.rarity }}</p>
          <p class="mb-1"><span class="font-medium">Collector Number:</span> {{ card.collector_number }}</p>
          <p v-if="card.collection" class="mb-1"><span class="font-medium">In Collection:</span> {{ card.collection.quantity_regular + card.collection.quantity_foil }}</p>
          <p v-if="card.kiosk"><span class="font-medium">In Kiosk:</span> {{ card.kiosk.quantity_regular + card.kiosk.quantity_foil }}</p>
        </div>
      </div>
    </div>

    <div class="pagination text-center mt-6">
      <button @click="changePage(-1)" :disabled="currentPage === 1" class="px-4 py-2 mr-2">Previous</button>
      <span class="px-4 py-2 bg-secondary rounded">Page {{ currentPage }} of {{ totalPages }}</span>
      <button @click="changePage(1)" :disabled="currentPage === totalPages" class="px-4 py-2 ml-2">Next</button>
    </div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import axios from 'axios'

export default {
  name: 'SetDetails',
  props: {
    setCode: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const set = ref(null)
    const cards = ref([])
    const filters = ref({ name: '', rarity: '' })
    const currentPage = ref(1)
    const totalPages = ref(1)

    const fetchSet = async () => {
      try {
        const response = await axios.get(`/api/sets/${props.setCode}`)
        set.value = response.data
      } catch (error) {
        console.error('Error fetching set details:', error)
      }
    }

    const fetchCards = async () => {
      try {
        const response = await axios.get(`/api/sets/${props.setCode}/cards`, {
          params: {
            ...filters.value,
            page: currentPage.value
          }
        })
        cards.value = response.data.cards
        totalPages.value = response.data.pages
      } catch (error) {
        console.error('Error fetching set cards:', error)
      }
    }

    const changePage = (delta) => {
      currentPage.value += delta
      fetchCards()
    }

    onMounted(() => {
      fetchSet()
      fetchCards()
    })

    return {
      set,
      cards,
      filters,
      currentPage,
      totalPages,
      fetchCards,
      changePage
    }
  }
}
</script>
== End of frontend/src/views/SetDetails.vue ==

== Start of frontend/src/views/Sets.vue ==
<template>
  <div class="container">
    <h1 class="text-center text-2xl font-bold mb-4">Magic: The Gathering Sets</h1>
    <div v-if="loading" class="text-center text-lg">Loading sets...</div>
    <div v-else-if="error" class="error text-center text-lg text-error">Error: {{ error }}</div>
    <div v-else-if="sets.length === 0" class="text-center text-lg">No sets found.</div>
    <div v-else>
      <p class="text-center mb-4">Total sets: {{ sets.length }}</p>
      <div class="set-grid grid grid-cols-auto gap-4">
        <div v-for="set in sets" :key="set.code" class="card p-4">
          <router-link :to="{ name: 'SetDetails', params: { setCode: set.code } }" class="block">
            <img :src="set.icon_svg_uri" :alt="set.name" class="w-12 h-12 mx-auto mb-2" />
            <h2 class="text-lg font-semibold mb-2">{{ set.name }}</h2>
            <p class="mb-2">Released: {{ formatDate(set.released_at) }}</p>
            <div class="progress-container mb-2">
              <div
                class="progress-bar"
                :style="{ width: `${set.collection_percentage}%`, backgroundColor: getProgressColor(set.collection_percentage) }"
              ></div>
            </div>
            <p class="collection-status font-bold">{{ formatCollectionProgress(set) }}</p>
          </router-link>
        </div>
      </div>
      <div class="pagination text-center mt-6">
        <button @click="changePage(-1)" :disabled="currentPage === 1" class="px-4 py-2 mr-2">Previous</button>
        <span class="px-4 py-2 bg-secondary rounded">Page {{ currentPage }} of {{ totalPages }}</span>
        <button @click="changePage(1)" :disabled="currentPage === totalPages" class="px-4 py-2 ml-2">Next</button>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import axios from 'axios'

export default {
  name: 'Sets',
  setup() {
    const sets = ref([])
    const filters = ref({ name: '', set_type: '' })
    const currentPage = ref(1)
    const totalPages = ref(1)
    const loading = ref(true)
    const error = ref(null)

    const fetchSets = async () => {
      loading.value = true
      error.value = null
      try {
        const response = await axios.get('/api/sets', {
          params: {
            ...filters.value,
            page: currentPage.value
          }
        })
        sets.value = response.data.sets
        totalPages.value = response.data.pages
      } catch (err) {
        console.error('Error fetching sets:', err)
        error.value = 'Failed to load sets'
      } finally {
        loading.value = false
      }
    }

    const changePage = (delta) => {
      currentPage.value += delta
      fetchSets()
    }

    const formatDate = (dateString) => {
      return dateString ? new Date(dateString).toLocaleDateString() : 'N/A'
    }

    const formatCollectionProgress = (set) => {
      if (set.collection_count === 0) {
        return 'Not Started (0%)'
      } else if (set.collection_count === set.card_count) {
        return 'Complete (100%)'
      } else {
        return `${set.collection_count}/${set.card_count} (${set.collection_percentage.toFixed(2)}%)`
      }
    }

    const getProgressColor = (percentage) => {
      if (percentage === 0) return '#95a5a6'
      if (percentage < 25) return '#e74c3c'
      if (percentage < 50) return '#e67e22'
      if (percentage < 75) return '#f1c40f'
      if (percentage < 100) return '#2ecc71'
      return '#3498db'
    }

    onMounted(fetchSets)

    return {
      sets,
      filters,
      currentPage,
      totalPages,
      loading,
      error,
      fetchSets,
      changePage,
      formatDate,
      formatCollectionProgress,
      getProgressColor
    }
  }
}
</script>
== End of frontend/src/views/Sets.vue ==

